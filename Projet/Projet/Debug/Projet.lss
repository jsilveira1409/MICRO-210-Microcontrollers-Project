
AVRASM ver. 2.2.6  C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\main.asm Fri Apr 23 14:51:38 2021

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\main.asm(1): Including file 'C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\lib/macros.asm'
C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\main.asm(2): Including file 'C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\lib/definitions.asm'
C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\main.asm(38): Including file 'C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\lib/printf.asm'
C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\main.asm(39): Including file 'C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\lib/lcd.asm'
C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\main.asm(40): Including file 'C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\lib/encoder.asm'
C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\main.asm(41): Including file 'C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\lib/menu.asm'
C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\main.asm(42): Including file 'C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\lib/eeprom.asm'
C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\main.asm(45): Including file 'C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\libPerso/per_sensors.asm'
C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\main.asm(46): Including file 'C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\libPerso/per_wire1.asm'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\main.asm(1): Including file 'C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\lib/macros.asm'
C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\main.asm(2): Including file 'C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\lib/definitions.asm'
C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\main.asm(38): Including file 'C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\lib/printf.asm'
C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\main.asm(39): Including file 'C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\lib/lcd.asm'
C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\main.asm(40): Including file 'C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\lib/encoder.asm'
C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\main.asm(41): Including file 'C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\lib/menu.asm'
C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\main.asm(42): Including file 'C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\lib/eeprom.asm'
C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\main.asm(45): Including file 'C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\libPerso/per_sensors.asm'
C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\main.asm(46): Including file 'C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\libPerso/per_wire1.asm'
                                 
                                 .include "lib/macros.asm"
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #define _M128DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega128
                                 #pragma AVRPART ADMIN PART_NAME ATmega128
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x97
                                 .equ	SIGNATURE_002	= 0x02
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UCSR1C	= 0x9d	; MEMORY MAPPED
                                 .equ	UDR1	= 0x9c	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0x9b	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0x9a	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0x98	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0x99	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0x95	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0x90	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x8c	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x8b	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x8a	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x88	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x89	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x86	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x87	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x84	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x85	; MEMORY MAPPED
                                 .equ	OCR3CL	= 0x82	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x83	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x80	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x81	; MEMORY MAPPED
                                 .equ	ETIMSK	= 0x7d	; MEMORY MAPPED
                                 .equ	ETIFR	= 0x7c	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x7a	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x78	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x79	; MEMORY MAPPED
                                 .equ	TWCR	= 0x74	; MEMORY MAPPED
                                 .equ	TWDR	= 0x73	; MEMORY MAPPED
                                 .equ	TWAR	= 0x72	; MEMORY MAPPED
                                 .equ	TWSR	= 0x71	; MEMORY MAPPED
                                 .equ	TWBR	= 0x70	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x6f	; MEMORY MAPPED
                                 .equ	XMCRA	= 0x6d	; MEMORY MAPPED
                                 .equ	XMCRB	= 0x6c	; MEMORY MAPPED
                                 .equ	EICRA	= 0x6a	; MEMORY MAPPED
                                 .equ	SPMCSR	= 0x68	; MEMORY MAPPED
                                 .equ	PORTG	= 0x65	; MEMORY MAPPED
                                 .equ	DDRG	= 0x64	; MEMORY MAPPED
                                 .equ	PING	= 0x63	; MEMORY MAPPED
                                 .equ	PORTF	= 0x62	; MEMORY MAPPED
                                 .equ	DDRF	= 0x61	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	XDIV	= 0x3c
                                 .equ	RAMPZ	= 0x3b
                                 .equ	EICRB	= 0x3a
                                 .equ	EIMSK	= 0x39
                                 .equ	EIFR	= 0x38
                                 .equ	TIMSK	= 0x37
                                 .equ	TIFR	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUCSR	= 0x34
                                 .equ	TCCR0	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OCR0	= 0x31
                                 .equ	ASSR	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	ICR1L	= 0x26
                                 .equ	ICR1H	= 0x27
                                 .equ	TCCR2	= 0x25
                                 .equ	TCNT2	= 0x24
                                 .equ	OCR2	= 0x23
                                 .equ	OCDR	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	SFIOR	= 0x20
                                 .equ	EEARL	= 0x1e
                                 .equ	EEARH	= 0x1f
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTA	= 0x1b
                                 .equ	DDRA	= 0x1a
                                 .equ	PINA	= 0x19
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PORTC	= 0x15
                                 .equ	DDRC	= 0x14
                                 .equ	PINC	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	SPDR	= 0x0f
                                 .equ	SPSR	= 0x0e
                                 .equ	SPCR	= 0x0d
                                 .equ	UDR0	= 0x0c
                                 .equ	UCSR0A	= 0x0b
                                 .equ	UCSR0B	= 0x0a
                                 .equ	UBRR0L	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	ADMUX	= 0x07
                                 .equ	ADCSRA	= 0x06
                                 .equ	ADCH	= 0x05
                                 .equ	ADCL	= 0x04
                                 .equ	PORTE	= 0x03
                                 .equ	DDRE	= 0x02
                                 .equ	PINE	= 0x01
                                 .equ	PINF	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; SFIOR - Special Function IO Register
                                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWBR - TWI Bit Rate register
                                 .equ	I2BR	= TWBR	; For compatibility
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	I2CR	= TWCR	; For compatibility
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	I2IE	= TWIE	; For compatibility
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	I2EN	= TWEN	; For compatibility
                                 .equ	ENI2C	= TWEN	; For compatibility
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	I2WC	= TWWC	; For compatibility
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	I2STO	= TWSTO	; For compatibility
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	I2STA	= TWSTA	; For compatibility
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	I2EA	= TWEA	; For compatibility
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 .equ	I2INT	= TWINT	; For compatibility
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	I2SR	= TWSR	; For compatibility
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWS0	= TWPS0	; For compatibility
                                 .equ	I2GCE	= TWPS0	; For compatibility
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS1	= TWPS1	; For compatibility
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	I2S3	= TWS3	; For compatibility
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	I2S4	= TWS4	; For compatibility
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	I2S5	= TWS5	; For compatibility
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	I2S6	= TWS6	; For compatibility
                                 .equ	TWS7	= 7	; TWI Status
                                 .equ	I2S7	= TWS7	; For compatibility
                                 
                                 ; TWDR - TWI Data register
                                 .equ	I2DR	= TWDR	; For compatibility
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	I2AR	= TWAR	; For compatibility
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR00	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR01	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR02	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR03	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR04	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR05	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR06	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR07	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	UCSZ2	= UCSZ02	; For compatibility
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL0	= 6	; USART Mode Select
                                 
                                 ; UBRR0H - USART Baud Rate Register Hight Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR10	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR11	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR12	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR13	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR14	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR15	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR16	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR17	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL1	= 6	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register Hight Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	SM2	= 2	; Sleep Mode Select
                                 .equ	SM0	= 3	; Sleep Mode Select
                                 .equ	SM1	= 4	; Sleep Mode Select
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	SRW10	= 6	; External SRAM Wait State Select
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; XMCRA - External Memory Control Register A
                                 .equ	SRW11	= 1	; Wait state select bit upper page
                                 .equ	SRW00	= 2	; Wait state select bit lower page
                                 .equ	SRW01	= 3	; Wait state select bit lower page
                                 .equ	SRL0	= 4	; Wait state page limit
                                 .equ	SRL1	= 5	; Wait state page limit
                                 .equ	SRL2	= 6	; Wait state page limit
                                 
                                 ; XMCRB - External Memory Control Register B
                                 .equ	XMM0	= 0	; External Memory High Mask
                                 .equ	XMM1	= 1	; External Memory High Mask
                                 .equ	XMM2	= 2	; External Memory High Mask
                                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value
                                 .equ	CAL1	= 1	; Oscillator Calibration Value
                                 .equ	CAL2	= 2	; Oscillator Calibration Value
                                 .equ	CAL3	= 3	; Oscillator Calibration Value
                                 .equ	CAL4	= 4	; Oscillator Calibration Value
                                 .equ	CAL5	= 5	; Oscillator Calibration Value
                                 .equ	CAL6	= 6	; Oscillator Calibration Value
                                 .equ	CAL7	= 7	; Oscillator Calibration Value
                                 
                                 ; XDIV - XTAL Divide Control Register
                                 .equ	XDIV0	= 0	; XTAl Divide Select Bit 0
                                 .equ	XDIV1	= 1	; XTAl Divide Select Bit 1
                                 .equ	XDIV2	= 2	; XTAl Divide Select Bit 2
                                 .equ	XDIV3	= 3	; XTAl Divide Select Bit 3
                                 .equ	XDIV4	= 4	; XTAl Divide Select Bit 4
                                 .equ	XDIV5	= 5	; XTAl Divide Select Bit 5
                                 .equ	XDIV6	= 6	; XTAl Divide Select Bit 6
                                 .equ	XDIVEN	= 7	; XTAL Divide Enable
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; RAMPZ - RAM Page Z Select Register
                                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMCR	= SPMCSR	; For compatibility
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	ASRE	= RWWSRE	; For compatibility
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	ASB	= RWWSB	; For compatibility
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 
                                 ; ***** MISC *************************
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR321	= 0	; Prescaler Reset Timer/Counter3, Timer/Counter2, and Timer/Counter1
                                 .equ	PSR1	= PSR321	; For compatibility
                                 .equ	PSR2	= PSR321	; For compatibility
                                 .equ	PSR3	= PSR321	; For compatibility
                                 .equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 .equ	PUD	= 2	; Pull Up Disable
                                 ;.equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	GICR	= EIMSK	; For compatibility
                                 .equ	GIMSK	= EIMSK	; For compatibility
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	GIFR	= EIFR	; For compatibility
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE3	= 3	; 
                                 .equ	PE3	= 3	; For compatibility
                                 .equ	PORTE4	= 4	; 
                                 .equ	PE4	= 4	; For compatibility
                                 .equ	PORTE5	= 5	; 
                                 .equ	PE5	= 5	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 .equ	PORTE7	= 7	; 
                                 .equ	PE7	= 7	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE3	= 3	; 
                                 .equ	DDE4	= 4	; 
                                 .equ	DDE5	= 5	; 
                                 .equ	DDE6	= 6	; 
                                 .equ	DDE7	= 7	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 .equ	PINE4	= 4	; 
                                 .equ	PINE5	= 5	; 
                                 .equ	PINE6	= 6	; 
                                 .equ	PINE7	= 7	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF2	= 2	; 
                                 .equ	PF2	= 2	; For compatibility
                                 .equ	PORTF3	= 3	; 
                                 .equ	PF3	= 3	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF2	= 2	; 
                                 .equ	DDF3	= 3	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF2	= 2	; 
                                 .equ	PINF3	= 3	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** PORTG ************************
                                 ; PORTG - Data Register, Port G
                                 .equ	PORTG0	= 0	; 
                                 .equ	PG0	= 0	; For compatibility
                                 .equ	PORTG1	= 1	; 
                                 .equ	PG1	= 1	; For compatibility
                                 .equ	PORTG2	= 2	; 
                                 .equ	PG2	= 2	; For compatibility
                                 .equ	PORTG3	= 3	; 
                                 .equ	PG3	= 3	; For compatibility
                                 .equ	PORTG4	= 4	; 
                                 .equ	PG4	= 4	; For compatibility
                                 
                                 ; DDRG - Data Direction Register, Port G
                                 .equ	DDG0	= 0	; 
                                 .equ	DDG1	= 1	; 
                                 .equ	DDG2	= 2	; 
                                 .equ	DDG3	= 3	; 
                                 .equ	DDG4	= 4	; 
                                 
                                 ; PING - Input Pins, Port G
                                 .equ	PING0	= 0	; 
                                 .equ	PING1	= 1	; 
                                 .equ	PING2	= 2	; 
                                 .equ	PING3	= 3	; 
                                 .equ	PING4	= 4	; 
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0 - Timer/Counter Control Register
                                 .equ	CS00	= 0	; Clock Select 0
                                 .equ	CS01	= 1	; Clock Select 1
                                 .equ	CS02	= 2	; Clock Select 2
                                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                                 .equ	CTC0	= WGM01	; For compatibility
                                 .equ	COM00	= 4	; Compare match Output Mode 0
                                 .equ	COM01	= 5	; Compare Match Output Mode 1
                                 .equ	WGM00	= 6	; Waveform Generation Mode 0
                                 .equ	PWM0	= WGM00	; For compatibility
                                 .equ	FOC0	= 7	; Force Output Compare
                                 
                                 ; TCNT0 - Timer/Counter Register
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0 - Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; ASSR - Asynchronus Status Register
                                 .equ	TCR0UB	= 0	; Timer/Counter Control Register 0 Update Busy
                                 .equ	OCR0UB	= 1	; Output Compare register 0 Busy
                                 .equ	TCN0UB	= 2	; Timer/Counter0 Update Busy
                                 .equ	AS0	= 3	; Asynchronus Timer/Counter 0
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0	= 1	; Timer/Counter0 Output Compare Match Interrupt register
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0	= 1	; Output Compare Flag 0
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE1C	= 0	; Timer/Counter 1, Output Compare Match C Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF1C	= 0	; Timer/Counter 1, Output Compare C Match Flag
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Clock Select bit 0
                                 .equ	CS11	= 1	; Clock Select 1 bit 1
                                 .equ	CS12	= 2	; Clock Select1 bit 2
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	CTC10	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	CTC11	= WGM13	; For compatibility
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare for channel C
                                 .equ	FOC1B	= 6	; Force Output Compare for channel B
                                 .equ	FOC1A	= 7	; Force Output Compare for channel A
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TCCR2 - Timer/Counter Control Register
                                 .equ	CS20	= 0	; Clock Select
                                 .equ	CS21	= 1	; Clock Select
                                 .equ	CS22	= 2	; Clock Select
                                 .equ	WGM21	= 3	; Waveform Generation Mode
                                 .equ	CTC2	= WGM21	; For compatibility
                                 .equ	COM20	= 4	; Compare Match Output Mode
                                 .equ	COM21	= 5	; Compare Match Output Mode
                                 .equ	WGM20	= 6	; Wafeform Generation Mode
                                 .equ	PWM2	= WGM20	; For compatibility
                                 .equ	FOC2	= 7	; Force Output Compare
                                 
                                 ; TCNT2 - Timer/Counter Register
                                 .equ	TCNT2_0	= 0	; Timer/Counter Register Bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter Register Bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter Register Bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter Register Bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter Register Bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter Register Bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter Register Bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter Register Bit 7
                                 
                                 ; OCR2 - Output Compare Register
                                 .equ	OCR2_0	= 0	; Output Compare Register Bit 0
                                 .equ	OCR2_1	= 1	; Output Compare Register Bit 1
                                 .equ	OCR2_2	= 2	; Output Compare Register Bit 2
                                 .equ	OCR2_3	= 3	; Output Compare Register Bit 3
                                 .equ	OCR2_4	= 4	; Output Compare Register Bit 4
                                 .equ	OCR2_5	= 5	; Output Compare Register Bit 5
                                 .equ	OCR2_6	= 6	; Output Compare Register Bit 6
                                 .equ	OCR2_7	= 7	; Output Compare Register Bit 7
                                 
                                 ; TIMSK - 
                                 .equ	TOIE2	= 6	; 
                                 .equ	OCIE2	= 7	; 
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2	= 7	; Output Compare Flag 2
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE3C	= 1	; Timer/Counter3, Output Compare Match Interrupt Enable
                                 .equ	TOIE3	= 2	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3B	= 3	; Timer/Counter3 Output CompareB Match Interrupt Enable
                                 .equ	OCIE3A	= 4	; Timer/Counter3 Output CompareA Match Interrupt Enable
                                 .equ	TICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF3C	= 1	; Timer/Counter3 Output Compare C Match Flag
                                 .equ	TOV3	= 2	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3B	= 3	; Output Compare Flag 1B
                                 .equ	OCF3A	= 4	; Output Compare Flag 1A
                                 .equ	ICF3	= 5	; Input Capture Flag 1
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	PSR1	= PSR321	; For compatibility
                                 ;.equ	PSR2	= PSR321	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM30	= WGM30	; For compatibility
                                 .equ	WGM31	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM31	= WGM31	; For compatibility
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Comparet Ouput Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 3A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Clock Select 3 bit 0
                                 .equ	CS31	= 1	; Clock Select 3 bit 1
                                 .equ	CS32	= 2	; Clock Select3 bit 2
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	CTC30	= WGM32	; For compatibility
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	CTC31	= WGM33	; For compatibility
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3  Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare for channel C
                                 .equ	FOC3B	= 6	; Force Output Compare for channel B
                                 .equ	FOC3A	= 7	; Force Output Compare for channel A
                                 
                                 ; TCNT3L - Timer/Counter3 Low Byte
                                 .equ	TCN3L0	= 0	; Timer/Counter 3 bit 0
                                 .equ	TCN3L1	= 1	; Timer/Counter 3 bit 1
                                 .equ	TCN3L2	= 2	; Timer/Counter 3 bit 2
                                 .equ	TCN3L3	= 3	; Timer/Counter 3 bit 3
                                 .equ	TCN3L4	= 4	; Timer/Counter 3 bit 4
                                 .equ	TCN3L5	= 5	; Timer/Counter 3 bit 5
                                 .equ	TCN3L6	= 6	; Timer/Counter 3 bit 6
                                 .equ	TCN3L7	= 7	; Timer/Counter 3 bit 7
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADCSR	= ADCSRA	; For compatibility
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADFR	= 5	; ADC  Free Running Select
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	BODEN	= 6	; Brown out detector enable
                                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	CKOPT	= 4	; Oscillator Options
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	WDTON	= 0	; Watchdog timer always on
                                 .equ	M103C	= 1	; ATmega103 compatibility mode
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0xffff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 4096
                                 .equ	RAMEND	= 0x10ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x0fff
                                 .equ	EEPROMEND	= 0x0fff
                                 .equ	EEADRBITS	= 12
                                 #pragma AVRPART MEMORY PROG_FLASH 131072
                                 #pragma AVRPART MEMORY EEPROM 4096
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 4096
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0xf000
                                 .equ	NRWW_STOP_ADDR	= 0xffff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0xefff
                                 .equ	PAGESIZE	= 128
                                 .equ	FIRSTBOOTSTART	= 0xfe00
                                 .equ	SECONDBOOTSTART	= 0xfc00
                                 .equ	THIRDBOOTSTART	= 0xf800
                                 .equ	FOURTHBOOTSTART	= 0xf000
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                                 .equ	OC2addr	= 0x0012	; Timer/Counter2 Compare Match
                                 .equ	OVF2addr	= 0x0014	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0016	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0018	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x001a	; Timer/Counter Compare Match B
                                 .equ	OVF1addr	= 0x001c	; Timer/Counter1 Overflow
                                 .equ	OC0addr	= 0x001e	; Timer/Counter0 Compare Match
                                 .equ	OVF0addr	= 0x0020	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0024	; USART0, Rx Complete
                                 .equ	UDRE0addr	= 0x0026	; USART0 Data Register Empty
                                 .equ	UTXC0addr	= 0x0028	; USART0, Tx Complete
                                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                                 .equ	OC1Caddr	= 0x0030	; Timer/Counter1 Compare Match C
                                 .equ	ICP3addr	= 0x0032	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0034	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0036	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0038	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x003a	; Timer/Counter3 Overflow
                                 .equ	URXC1addr	= 0x003c	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x003e	; USART1, Data Register Empty
                                 .equ	UTXC1addr	= 0x0040	; USART1, Tx Complete
                                 .equ	TWIaddr	= 0x0042	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0044	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 70	; size in words
                                 
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 
                                 ; purpose library, general-purpose macros
                                 ; author (c) R.Holzer (adapted MICRO210/EE208 A.Schmid)
                                 ; v2019.01 20180820 AxS
                                 
                                 ; ==============
                                 ; 	pointers
                                 ; ==============
                                 
                                 ; --- loading an immediate into a pointer XYZ,SP ---
                                 .macro 	LDIX	; sram
                                 	ldi	xl, low(@0)
                                 	ldi	xh,high(@0)
                                 	.endmacro	
                                 .macro 	LDIY	; sram	
                                 	ldi	yl, low(@0)
                                 	ldi	yh,high(@0)
                                 	.endmacro	
                                 .macro 	LDIZ	; sram
                                 	ldi	zl, low(@0)
                                 	ldi	zh,high(@0)
                                 	
                                 	.endmacro
                                 .macro	LDZD	; sram, reg	; sram+reg -> Z
                                 	mov	zl,@1
                                 	clr	zh
                                 	subi	zl, low(-@0)
                                 	sbci	zh,high(-@0)
                                 	.endmacro
                                 .macro	LDSP	; sram
                                 	ldi	r16, low(@0)
                                 	out	spl,r16
                                 	ldi	r16,high(@0)
                                 	out	sph,r16
                                 	.endmacro
                                 
                                 ; --- load/store SRAM addr into pointer XYZ ---	
                                 .macro 	LDSX	; sram
                                 	lds	xl,@0
                                 	lds	xh,@0+1
                                 	.endmacro
                                 .macro 	LDSY	; sram
                                 	lds	yl,@0
                                 	lds	yh,@0+1
                                 	.endmacro
                                 .macro 	LDSZ	; sram
                                 	lds	zl,@0
                                 	lds	zh,@0+1
                                 	.endmacro
                                 .macro 	STSX	; sram
                                 	sts	@0,  xl
                                 	sts	@0+1,xh
                                 	.endmacro	
                                 .macro 	STSY	; sram
                                 	sts	@0,  yl
                                 	sts	@0+1,yh
                                 	.endmacro
                                 .macro 	STSZ	; sram
                                 	sts	@0,  zl
                                 	sts	@0+1,zh
                                 	.endmacro	
                                 
                                 ; --- push/pop pointer XYZ ---
                                 .macro	PUSHX			; push X
                                 	push	xl
                                 	push	xh
                                 	.endmacro
                                 .macro	POPX			; pop X
                                 	pop	xh
                                 	pop	xl
                                 	.endmacro
                                 	
                                 .macro	PUSHY			; push Y
                                 	push	yl
                                 	push	yh
                                 	.endmacro
                                 .macro	POPY			; pop Y
                                 	pop	yh
                                 	pop	yl
                                 	.endmacro
                                 
                                 .macro	PUSHZ			; push Z
                                 	push	zl
                                 	push	zh
                                 	.endmacro
                                 .macro	POPZ			; pop Z
                                 	pop	zh
                                 	pop	zl
                                 	.endmacro
                                 
                                 ; --- multiply/divide Z ---	
                                 .macro	MUL2Z			; multiply Z by 2
                                 	lsl	zl
                                 	rol	zh
                                 	.endmacro
                                 .macro	DIV2Z			; divide Z by 2
                                 	lsr	zh
                                 	ror	zl
                                 	.endmacro
                                 
                                 ; --- add register to pointer XYZ ---	
                                 .macro	ADDX	;reg		; x <- y+reg
                                 	add	xl,@0
                                 	brcc	PC+2
                                 	subi	xh,-1		; add carry
                                 	.endmacro
                                 .macro	ADDY	;reg		; y <- y+reg
                                 	add	yl,@0
                                 	brcc	PC+2
                                 	subi	yh,-1		; add carry
                                 	.endmacro
                                 .macro	ADDZ	;reg		; z <- z+reg
                                 	add	zl,@0
                                 	brcc	PC+2
                                 	subi	zh,-1		; add carry
                                 	.endmacro
                                 
                                 ; ===================
                                 ; 	miscellaneous
                                 ; ===================
                                 
                                 ; --- output/store (regular I/O space) immediate value ---
                                 .macro	OUTI	; port,k	output immediate value to port
                                 	ldi	w,@1
                                 	out	@0,w
                                 	.endmacro
                                 
                                 ; --- output/store (extended I/O space) immediate value ---
                                 .macro OUTEI	; port,k    output immediate value to port
                                 	ldi	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 ; --- add immediate value ---
                                 .macro	ADDI
                                 	subi	@0,-@1
                                 	.endmacro
                                 .macro	ADCI
                                 	sbci	@0,-@1
                                 	.endmacro
                                 
                                 ; --- inc/dec with range limitation ---
                                 .macro	INC_LIM	; reg,limit
                                 	cpi	@0,@1
                                 	brlo	PC+3
                                 	ldi	@0,@1	
                                 	rjmp	PC+2
                                 	inc	@0
                                 	.endmacro
                                 
                                 .macro	DEC_LIM	; reg,limit
                                 	cpi	@0,@1
                                 	breq	PC+5
                                 	brlo	PC+3
                                 	dec	@0
                                 	rjmp	PC+2
                                 	ldi	@0,@1
                                 	.endmacro
                                 
                                 ; --- inc/dec with cyclic range ---
                                 .macro	INC_CYC	; reg,low,high
                                 	cpi	@0,@2
                                 	brsh	_low	; reg>=high then reg=low
                                 	cpi	@0,@1
                                 	brlo	_low	; reg< low  then reg=low
                                 	inc	@0
                                 	rjmp	_done
                                 _low:	ldi	@0,@1
                                 _done:	
                                     .endmacro
                                 	
                                 .macro	DEC_CYC	; reg,low,high
                                 	cpi	@0,@1
                                 	breq	_high	; reg=low then reg=high
                                 	brlo	_high	; reg<low then reg=high
                                 	dec	@0	
                                 	cpi	@0,@2
                                 	brsh	_high	; reg>=high then high
                                 	rjmp	_done
                                 _high:	ldi	@0,@2
                                 _done:	
                                 	.endmacro
                                 
                                 .macro	INCDEC	;port,b1,b2,reg,low,high
                                 	sbic	@0,@1
                                 	rjmp	PC+6
                                 
                                 	cpi	@3,@5
                                 	brlo	PC+3
                                 	ldi	@3,@4	
                                 	rjmp	PC+2
                                 	inc	@3
                                 
                                 	sbic	@0,@2
                                 	rjmp	PC+7
                                 	
                                 	cpi	@3,@4
                                 	breq	PC+5
                                 	brlo	PC+3
                                 	dec	@3
                                 	rjmp	PC+2
                                 	ldi	@3,@5
                                 	.endmacro		
                                 
                                 ; --- wait loops ---
                                 ; wait 10...196608 cycles
                                 .macro	WAIT_C	; k
                                 	ldi	w,  low((@0-7)/3)
                                 	mov	u,w			; u=LSB
                                 	ldi	w,high((@0-7)/3)+1	; w=MSB
                                 	dec	u
                                 	brne	PC-1
                                 	dec	u
                                 	dec	w
                                 	brne	PC-4
                                 	.endmacro
                                 
                                 ; wait micro-seconds (us)
                                 ; us = x*3*1000'000/clock)	==> x=us*clock/3000'000
                                 .macro	WAIT_US ; k
                                 	ldi	w, low((clock/1000*@0/3000)-1)
                                 	mov	u,w
                                 	ldi	w,high((clock/1000*@0/3000)-1)+1 ; set up: 3 cyles
                                 	dec	u
                                 	brne	PC-1		; inner loop: 3 cycles
                                 	dec	u		; adjustment for outer loop
                                 	dec	w
                                 	brne	PC-4
                                 	.endmacro
                                 
                                 ; wait mili-seconds (ms)
                                 .macro	WAIT_MS ; k
                                 	ldi	w, low(@0)
                                 	mov	u,w		; u = LSB	
                                 	ldi	w,high(@0)+1	; w = MSB
                                 wait_ms:
                                 	push	w		; wait 1000 usec
                                 	push	u
                                 	ldi	w, low((clock/3000)-5)	
                                 	mov	u,w
                                 	ldi	w,high((clock/3000)-5)+1
                                 	dec	u
                                 	brne	PC-1		; inner loop: 3 cycles
                                 	dec	u		; adjustment for outer loop
                                 	dec	w
                                 	brne	PC-4
                                 	pop	u
                                 	pop	w
                                 	
                                 	dec	u
                                 	brne	wait_ms
                                 	dec	w
                                 	brne	wait_ms
                                 	.endmacro
                                 
                                 ; --- conditional jumps/calls ---
                                 .macro	JC0			; jump if carry=0
                                 	brcs	PC+2	
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JC1			; jump if carry=1
                                 	brcc	PC+2	
                                 	rjmp	@0
                                 	.endmacro
                                 
                                 .macro	JK	; reg,k,addr	; jump if reg=k
                                 	cpi	@0,@1
                                 	breq	@2
                                 	.endmacro
                                 .macro	_JK	; reg,k,addr	; jump if reg=k
                                 	cpi	@0,@1
                                 	brne	PC+2
                                 	rjmp	@2
                                 	.endmacro	
                                 .macro	JNK	; reg,k,addr	; jump if not(reg=k)
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro 
                                 
                                 .macro	CK	; reg,k,addr	; call if reg=k
                                 	cpi	@0,@1
                                 	brne	PC+2
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CNK	; reg,k,addr	; call if not(reg=k)
                                 	cpi	@0,@1
                                 	breq	PC+2
                                 	rcall	@2
                                 	.endmacro 
                                 
                                 .macro	JSK	; sram,k,addr	; jump if sram=k
                                 	lds	w,@0
                                 	cpi	w,@1
                                 	breq	@2
                                 	.endmacro 
                                 .macro	JSNK	; sram,k,addr	; jump if not(sram=k)
                                 	lds	w,@0
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 ; --- loops ---
                                 .macro	DJNZ	; reg,addr	; decr and jump if not zero
                                 	dec	@0
                                 	brne	@1
                                 	.endmacro
                                 .macro	DJNK	; reg,k,addr	; decr and jump if not k
                                 	dec	@0
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 .macro	IJNZ	; reg,addr	; inc and jump if not zero
                                 	inc	@0
                                 	brne	@1
                                 	.endmacro
                                 .macro	IJNK	; reg,k,addr	; inc and jump if not k
                                 	inc	@0
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro
                                 .macro	_IJNK	; reg,k,addr	; inc and jump if not k
                                 	inc	@0
                                 	ldi	w,@1
                                 	cp	@0,w
                                 	brne	@2
                                 	.endmacro
                                 
                                 .macro	ISJNK	; sram,k,addr	; inc sram and jump if not k
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 .macro	_ISJNK	; sram,k,addr	; inc sram and jump if not k
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	breq	PC+2	
                                 	rjmp	@2
                                 	.endmacro
                                 
                                 .macro	DSJNK	; sram,k,addr	; dec sram and jump if not k
                                 	lds	w,@0
                                 	dec	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 ; --- table lookup ---
                                 .macro	LOOKUP	;reg, index,tbl
                                 	push	ZL
                                 	push	ZH
                                 	mov	zl,@1		; move index into z
                                 	clr	zh
                                 	subi	zl, low(-2*@2)	; add base address of table
                                 	sbci	zh,high(-2*@2)	
                                 	lpm			; load program memory (into r0)
                                 	mov	@0,r0
                                 	pop	ZH
                                 	pop	ZL
                                 	.endmacro
                                 
                                 .macro	LOOKUP2	;r1,r0, index,tbl
                                 	mov	zl,@2		; move index into z
                                 	clr	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh
                                 	subi	zl, low(-2*@3)	; add base address of table
                                 	sbci	zh,high(-2*@3)
                                 	lpm			; get LSB byte
                                 	mov	w,r0		; temporary store LSB in w
                                 	adiw	zl,1		; increment Z
                                 	lpm			; get MSB byte
                                 	mov	@0,r0		; mov MSB to res1
                                 	mov	@1,w		; mov LSB to res0
                                 	.endmacro
                                 
                                 .macro	LOOKUP4	;r3,r2,r1,r0, index,tbl
                                 	mov	zl,@4		; move index into z
                                 	clr	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh	
                                 	subi	zl, low(-2*@5)	; add base address of table
                                 	sbci	zh,high(-2*@5)
                                 	lpm
                                 	mov	@1,r0		; load high word LSB
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0		; load high word MSB
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@3,r0		; load low word LSB		
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@2,r0		; load low word MSB
                                 	.endmacro
                                 
                                 .macro	LOOKDOWN ;reg,index,tbl
                                 	ldi	ZL, low(2*@2)	; load table address
                                 	ldi	ZH,high(2*@2)
                                 	clr	@1
                                 loop:	lpm
                                 	cp	r0,@0
                                 	breq	found
                                 	inc	@1
                                 	adiw	ZL,1
                                 	tst	r0
                                 	breq	notfound
                                 	rjmp	loop
                                 notfound:
                                 	ldi	@1,-1
                                 found:	
                                 	.endmacro
                                 
                                 ; --- branch table ---
                                 .macro	C_TBL	; reg,tbl
                                 	ldi	ZL, low(2*@1)
                                 	ldi	ZH,high(2*@1)
                                 	lsl	@0
                                 	add	ZL,@0
                                 	brcc	PC+2
                                 	inc	ZH
                                 	lpm
                                 	push	r0
                                 	lpm
                                 	mov	zh,r0
                                 	pop	zl
                                 	icall
                                 	.endmacro
                                 .macro	J_TBL	; reg,tbl	
                                 	ldi	ZL, low(2*@1)
                                 	ldi	ZH,high(2*@1)
                                 	lsl	@0
                                 	add	ZL,@0
                                 	brcc	PC+2
                                 	inc	ZH
                                 	lpm
                                 	push	r0
                                 	lpm
                                 	mov	zh,r0
                                 	pop	zl	
                                 	ijmp
                                 	.endmacro
                                 
                                 .macro	BRANCH	; reg		; branching using the stack
                                 	ldi	w, low(tbl)
                                 	add	w,@0
                                 	push	w
                                 	ldi	w,high(tbl)
                                 	brcc	PC+2
                                 	inc	w
                                 	push	w
                                 	ret
                                 tbl:
                                 	.endmacro	
                                 
                                 ; --- multiply/division ---
                                 .macro	DIV2	; reg
                                 	lsr	@0
                                 	.endmacro
                                 .macro	DIV4	; reg
                                 	lsr	@0
                                 	lsr	@0
                                 	.endmacro	
                                 .macro	DIV8	; reg
                                 	lsr	@0
                                 	lsr	@0
                                 	lsr	@0
                                 	.endmacro
                                 	
                                 .macro	MUL2	; reg
                                 	lsl	@0
                                 	.endmacro
                                 .macro	MUL4	; reg
                                 	lsl	@0
                                 	lsl	@0
                                 	.endmacro
                                 .macro	MUL8	; reg
                                 	lsl	@0
                                 	lsl	@0
                                 	lsl	@0
                                 	.endmacro
                                 
                                 ; ====================================
                                 ; 	extending existing instructios
                                 ; ====================================
                                 
                                 ; --- immediate ops with r0..r15 ---
                                 .macro	_ADDI
                                 	ldi	w,@1
                                 	add	@0,w
                                 	.endmacro
                                 .macro	_ADCI
                                 	ldi	w,@1
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	_SUBI
                                 	ldi	w,@1
                                 	sub	@0,w
                                 	.endmacro
                                 .macro	_SBCI
                                 	ldi	w,@1
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	_ANDI
                                 	ldi	w,@1
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_ORI
                                 	ldi	w,@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	_EORI
                                 	ldi	w,@1
                                 	eor	@0,w
                                 	.endmacro
                                 .macro	_SBR
                                 	ldi	w,@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	_CBR
                                 	ldi	w,~@1
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_CPI
                                 	ldi	w,@1
                                 	cp	@0,w
                                 	.endmacro
                                 .macro	_LDI
                                 	ldi	w,@1
                                 	mov	@0,w
                                 	.endmacro
                                 
                                 ; --- bit access for port p32..p63 ---
                                 .macro	_SBI
                                 	in	w,@0
                                 	ori	w,1<<@1
                                 	out	@0,w
                                 	.endmacro
                                 .macro	_CBI
                                 	in	w,@0
                                 	andi	w,~(1<<@1)
                                 	out	@0,w
                                 	.endmacro
                                 	
                                 ; --- extending branch distance to +/-2k ---
                                 .macro	_BREQ
                                 	brne	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRNE
                                 	breq	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRCS
                                 	brcc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRCC
                                 	brcs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRSH
                                 	brlo	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRLO
                                 	brsh	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRMI
                                 	brpl	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRPL
                                 	brmi	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRGE
                                 	brlt	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRLT
                                 	brge	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRHS
                                 	brhc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRHC
                                 	brhs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRTS
                                 	brtc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRTC
                                 	brts	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRVS
                                 	brvc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRVC
                                 	brvs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRIE
                                 	brid	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRID
                                 	brie	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 
                                 ; ====================
                                 ; 	bit operations
                                 ; ====================
                                 
                                 ; --- moving bits ---
                                 .macro	MOVB	; reg1,b1, reg2,b2	; reg1,bit1 <- reg2,bit2
                                 	bst	@2,@3
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	OUTB	; port1,b1, reg2,b2	; port1,bit1 <- reg2,bit2
                                 	sbrs	@2,@3
                                 	cbi	@0,@1
                                 	sbrc	@2,@3
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	INB	; reg1,b1, port2,b2	; reg1,bit1 <- port2,bit2
                                 	sbis	@2,@3
                                 	cbr	@0,1<<@1
                                 	sbic	@2,@3
                                 	sbr	@0,1<<@1
                                 	.endmacro
                                 
                                 .macro	Z2C				; zero to carry
                                 	sec
                                 	breq	PC+2	; (Z=1)
                                 	clc
                                 	.endmacro
                                 .macro	Z2INVC				; zero to inverse carry
                                 	sec
                                 	brne	PC+2	; (Z=0)
                                 	clc
                                 	.endmacro
                                 
                                 .macro	C2Z				; carry to zero
                                 	sez
                                 	brcs	PC+2	; (C=1)
                                 	clz
                                 	.endmacro
                                 
                                 .macro	B2C	; reg,b			; bit to carry
                                 	sbrc	@0,@1
                                 	sec
                                 	sbrs	@0,@1
                                 	clc
                                 	.endmacro
                                 .macro	C2B	; reg,b			; carry to bit
                                 	brcc	PC+2
                                 	sbr	@0,(1<<@1)
                                 	brcs	PC+2
                                 	cbr	@0,(1<<@1)
                                 	.endmacro
                                 .macro	P2C	; port,b		; port to carry
                                 	sbic	@0,@1
                                 	sec
                                 	sbis	@0,@1
                                 	clc
                                 	.endmacro
                                 .macro	C2P	; port,b		; carry to port
                                 	brcc	PC+2
                                 	sbi	@0,@1
                                 	brcs	PC+2
                                 	cbi	@0,@1
                                 	.endmacro
                                 
                                 ; --- inverting bits ---
                                 .macro	INVB	; reg,bit		; inverse reg,bit
                                 	ldi	w,(1<<@1)
                                 	eor	@0,w
                                 	.endmacro
                                 .macro	INVP	; port,bit		; inverse port,bit	
                                 	sbis	@0,@1
                                 	rjmp	PC+3
                                 	cbi	@0,@1
                                 	rjmp	PC+2
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	INVC				; inverse carry	
                                 	brcs	PC+3
                                 	sec
                                 	rjmp	PC+2
                                 	clc
                                 	.endmacro
                                 
                                 ; --- setting a single bit ---
                                 .macro	SETBIT	; reg(0..7)
                                 ; in	reg (0..7)
                                 ; out	reg with bit (0..7) set to 1.
                                 ; 0=00000001
                                 ; 1=00000010
                                 ; ...
                                 ; 7=10000000
                                 	mov	w,@0
                                 	clr	@0
                                 	inc	@0
                                 	andi	w,0b111	
                                 	breq	PC+4
                                 	lsl	@0
                                 	dec	w
                                 	brne	PC-2
                                 	.endmacro
                                 
                                 ; --- logical operations with masks ---
                                 .macro	MOVMSK	; reg1,reg2,mask	; reg1 <- reg2 (mask)
                                 	ldi	w,~@2	
                                 	and	@0,w
                                 	ldi	w,@2
                                 	and	@1,w	
                                 	or	@0,@1
                                 	.endmacro	
                                 .macro	ANDMSK	; reg1,reg2,mask	; reg1 <- ret 1 AND reg2 (mask)		
                                 	mov	w,@1
                                 	ori	w,~@2
                                 	and	@0,w
                                 	.endmacro	
                                 .macro	ORMSK	; reg1,reg2,mask	; reg1 <- ret 1 AND reg2 (mask)		
                                 	mov	w,@1
                                 	andi	w,@2
                                 	or	@0,w
                                 	.endmacro
                                 	
                                 ; --- logical operations on bits ---
                                 .macro	ANDB	; r1,b1, r2,b2, r3,b3	; reg1,b1 <- reg2,b2 AND reg3,b3
                                 	set
                                 	sbrs	@4,@5	
                                 	clt
                                 	sbrs	@2,@3	
                                 	clt
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	ORB	; r1,b1, r2,b2, r3,b3	; reg1.b1 <- reg2.b2 OR reg3.b3
                                 	clt
                                 	sbrc	@4,@5	
                                 	set
                                 	sbrc	@2,@3	
                                 	set
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	EORB	; r1,b1, r2,b2, r3,b3	; reg1.b1 <- reg2.b2 XOR reg3.b3
                                 	sbrc	@4,@5
                                 	rjmp	f1
                                 f0:	bst	@2,@3	
                                 	rjmp	PC+4
                                 f1:	set
                                 	sbrc	@0,@1
                                 	clt
                                 	bld	@0,@0	
                                 	.endmacro
                                 	
                                 ; --- operations based on register bits ---
                                 .macro	FB0	; reg,bit		; bit=0
                                 	cbr	@0,1<<@1
                                 	.endmacro
                                 .macro	FB1	; reg,bit		; bit=1
                                 	sbr	@0,1<<@1
                                 	.endmacro
                                 .macro	_FB0	; reg,bit		; bit=0
                                 	ldi	w,~(1<<@1)
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_FB1	; reg,bit		; bit=1
                                 	ldi	w,1<<@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	SB0	; reg,bit,addr		; skip if bit=0
                                 	sbrc	@0,@1
                                 	.endmacro
                                 .macro	SB1	; reg,bit,addr		; skip if bit=1
                                 	sbrs	@0,@1
                                 	.endmacro
                                 .macro	JB0	; reg,bit,addr		; jump if bit=0
                                 	sbrs	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	JB1	; reg,bit,addr		; jump if bit=1
                                 	sbrc	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	CB0	; reg,bit,addr		; call if bit=0
                                 	sbrs	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CB1	; reg,bit,addr		; call if bit=1
                                 	sbrc	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	WB0	; reg,bit		; wait if bit=0
                                 	sbrs	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	WB1	; reg,bit		; wait if bit=1
                                 	sbrc	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	RB0	; reg,bit		; return if bit=0
                                 	sbrs	@0,@1
                                 	ret
                                 	.endmacro
                                 .macro	RB1	; reg,bit		; return if bit=1
                                 	sbrc	@0,@1
                                 	ret
                                 	.endmacro
                                 
                                 ; wait if bit=0 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr
                                 .macro	WB0T	; reg,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbrs	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro
                                 
                                 ; wait if bit=1 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr	
                                 .macro	WB1T	; reg,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbrc	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro	
                                 	
                                 ; --- operations based on port bits ---
                                 .macro	P0	; port,bit		; port=0
                                 	cbi	@0,@1
                                 	.endmacro
                                 .macro	P1	; port,bit		; port=1
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	SP0	; port,bit		; skip if port=0
                                 	sbic	@0,@1
                                 	.endmacro
                                 .macro	SP1	; port,bit		; skip if port=1
                                 	sbis	@0,@1
                                 	.endmacro
                                 .macro	JP0	; port,bit,addr		; jump if port=0
                                 	sbis	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	JP1	; port,bit,addr		; jump if port=1
                                 	sbic	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	CP0	; port,bit,addr		; call if port=0
                                 	sbis	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CP1	; port,bit,addr		; call if port=1
                                 	sbic	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	WP0	; port,bit		; wait if port=0
                                 	sbis	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	WP1	; port,bit		; wait if port=1
                                 	sbic	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	RP0	; port,bit		; return if port=0
                                 	sbis	@0,@1
                                 	ret
                                 	.endmacro
                                 .macro	RP1	; port,bit		; return if port=1
                                 	sbic	@0,@1
                                 	ret
                                 	.endmacro
                                 
                                 ; wait if port=0 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr
                                 .macro	WP0T	; port,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbis	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro
                                 
                                 ; wait if port=1 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr	
                                 .macro	WP1T	; port,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbic	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro	
                                 
                                 ; ===========================
                                 ; 	multi-byte operations
                                 ; ===========================
                                 
                                 .macro	SWAP4			; swap 2 variables
                                 	mov	w ,@0
                                 	mov	@0,@4
                                 	mov	@4,w
                                 	mov	w ,@1
                                 	mov	@1,@5
                                 	mov	@5,w
                                 	mov	w ,@2
                                 	mov	@2,@6
                                 	mov	@6,w
                                 	mov	w ,@3
                                 	mov	@3,@7
                                 	mov	@7,w
                                 	.endmacro
                                 .macro	SWAP3
                                 	mov	w ,@0
                                 	mov	@0,@3
                                 	mov	@3,w
                                 	mov	w ,@1
                                 	mov	@1,@4
                                 	mov	@4,w
                                 	mov	w ,@2
                                 	mov	@2,@5
                                 	mov	@5,w
                                 	.endmacro
                                 .macro	SWAP2
                                 	mov	w ,@0
                                 	mov	@0,@2
                                 	mov	@2,w
                                 	mov	w ,@1
                                 	mov	@1,@3
                                 	mov	@3,w
                                 	.endmacro
                                 .macro	SWAP1
                                 	mov	w ,@0
                                 	mov	@0,@1
                                 	mov	@1,w
                                 	.endmacro
                                 
                                 .macro	LDX4	;r..r0		; load from (x+)
                                 	ld	@3,x+
                                 	ld	@2,x+	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 .macro	LDX3	;r..r0
                                 	ld	@2,x+	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 .macro	LDX2	;r..r0	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 	
                                 .macro	LDY4	;r..r0		; load from (y+)
                                 	ld	@3,y+
                                 	ld	@2,y+	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 .macro	LDY3	;r..r0
                                 	ld	@2,y+	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 .macro	LDY2	;r..r0	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 
                                 .macro	LDZ4	;r..r0		; load from (z+)
                                 	ld	@3,z+
                                 	ld	@2,z+	
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 .macro	LDZ3	;r..r0
                                 	ld	@2,z+	
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 .macro	LDZ2	;r..r0
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 
                                 .macro	STX4	;r..r0		; store to (x+)
                                 	st	x+,@3
                                 	st	x+,@2	
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 .macro	STX3	;r..r0
                                 	st	x+,@2	
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 .macro	STX2	;r..r0
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 	
                                 .macro	STY4	;r..r0		; store to (y+)
                                 	st	y+,@3
                                 	st	y+,@2	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 .macro	STY3	;r..r0
                                 	st	y+,@2	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 .macro	STY2	;r..r0	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 	
                                 .macro	STZ4	;r..r0		; store to (z+)
                                 	st	z+,@3
                                 	st	z+,@2	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 .macro	STZ3	;r..r0
                                 	st	z+,@2	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 .macro	STZ2	;r..r0	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 	
                                 .macro	STI4	;addr,k		; store immediate
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	ldi	w,byte3(@1)
                                 	sts	@0+2,w
                                 	ldi	w,byte4(@1)
                                 	sts	@0+3,w	
                                 	.endmacro	
                                 .macro	STI3	;addr,k
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	ldi	w,byte3(@1)
                                 	sts	@0+2,w
                                 	.endmacro	
                                 .macro	STI2	;addr,k
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	.endmacro
                                 .macro	STI	;addr,k
                                 	ldi	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	INC4			; increment
                                 	ldi	w,0xff
                                 	sub	@3,w
                                 	sbc	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	INC3
                                 	ldi	w,0xff
                                 	sub	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	INC2
                                 	ldi	w,0xff
                                 	sub	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 
                                 .macro	DEC4			; decrement
                                 	ldi	w,0xff
                                 	add	@3,w
                                 	adc	@2,w
                                 	adc	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	DEC3
                                 	ldi	w,0xff
                                 	add	@2,w
                                 	adc	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	DEC2
                                 	ldi	w,0xff
                                 	add	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 
                                 .macro	CLR9			; clear (also clears the carry)
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	clr	@7
                                 	clr	@8
                                 	.endmacro
                                 .macro	CLR8
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	clr	@7
                                 	.endmacro
                                 .macro	CLR7
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	.endmacro
                                 .macro	CLR6
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	.endmacro
                                 .macro	CLR5
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	.endmacro
                                 .macro	CLR4
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	.endmacro
                                 .macro	CLR3
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	.endmacro
                                 .macro	CLR2
                                 	sub	@0,@0
                                 	clr	@1
                                 	.endmacro
                                 
                                 .macro	COM4			; one's complement
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	com	@3
                                 	.endmacro
                                 .macro	COM3
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	.endmacro
                                 .macro	COM2
                                 	com	@0
                                 	com	@1
                                 	.endmacro
                                 
                                 .macro	NEG4			; negation (two's complement)
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	com	@3
                                 	ldi	w,0xff
                                 	sub	@3,w
                                 	sbc	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	NEG3
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	ldi	w,0xff
                                 	sub	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	NEG2
                                 	com	@0
                                 	com	@1
                                 	ldi	w,0xff
                                 	sub	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 	
                                 .macro	LDI4 	; r..r0, k	; load immediate
                                 	ldi	@3,  low(@4)
                                 	ldi	@2, high(@4)
                                 	ldi	@1,byte3(@4)
                                 	ldi	@0,byte4(@4)
                                 	.endmacro
                                 .macro	LDI3
                                 	ldi	@2,  low(@3)
                                 	ldi	@1, high(@3)
                                 	ldi	@0,byte3(@3)
                                 	.endmacro
                                 .macro	LDI2
                                 	ldi	@1,  low(@2)
                                 	ldi	@0, high(@2)
                                 	.endmacro
                                 
                                 .macro	LDS4			; load direct from SRAM
                                 	lds	@3,@4
                                 	lds	@2,@4+1
                                 	lds	@1,@4+2
                                 	lds	@0,@4+3
                                 	.endmacro
                                 .macro	LDS3
                                 	lds	@2,@3
                                 	lds	@1,@3+1
                                 	lds	@0,@3+2
                                 	.endmacro
                                 .macro	LDS2
                                 	lds	@1,@2
                                 	lds	@0,@2+1
                                 	.endmacro
                                 
                                 .macro	STS4			; store direct to SRAM
                                 	sts	@0+0,@4
                                 	sts	@0+1,@3
                                 	sts	@0+2,@2
                                 	sts	@0+3,@1
                                 	.endmacro
                                 .macro	STS3
                                 	sts	@0+0,@3
                                 	sts	@0+1,@2
                                 	sts	@0+2,@1
                                 	.endmacro
                                 .macro	STS2
                                 	sts	@0+0,@2
                                 	sts	@0+1,@1
                                 	.endmacro
                                 
                                 .macro	STDZ4	; d, r3,r2,r1,r0
                                 	std	z+@0+0,@4
                                 	std	z+@0+1,@3
                                 	std	z+@0+2,@2
                                 	std	z+@0+3,@1
                                 	.endmacro
                                 .macro	STDZ3	; d, r2,r1,r0
                                 	std	z+@0+0,@3
                                 	std	z+@0+1,@2
                                 	std	z+@0+2,@1
                                 	.endmacro
                                 .macro	STDZ2	; d, r1,r0
                                 	std	z+@0+0,@2
                                 	std	z+@0+1,@1
                                 	.endmacro
                                 	
                                 .macro	LPM4			; load program memory
                                 	lpm
                                 	mov	@3,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@2,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM3
                                 	lpm
                                 	mov	@2,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM2
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 
                                 .macro	MOV4			; move between registers
                                 	mov	@3,@7
                                 	mov	@2,@6
                                 	mov	@1,@5
                                 	mov	@0,@4
                                 	.endmacro
                                 .macro	MOV3
                                 	mov	@2,@5
                                 	mov	@1,@4
                                 	mov	@0,@3
                                 	.endmacro
                                 .macro	MOV2
                                 	mov	@1,@3
                                 	mov	@0,@2
                                 	.endmacro
                                 
                                 .macro	ADD4			; add
                                 	add	@3,@7
                                 	adc	@2,@6
                                 	adc	@1,@5
                                 	adc	@0,@4
                                 	.endmacro
                                 .macro	ADD3
                                 	add	@2,@5
                                 	adc	@1,@4
                                 	adc	@0,@3
                                 	.endmacro
                                 .macro	ADD2
                                 	add	@1,@3
                                 	adc	@0,@2
                                 	.endmacro
                                 
                                 .macro	SUB4			; subtract
                                 	sub	@3,@7
                                 	sbc	@2,@6
                                 	sbc	@1,@5
                                 	sbc	@0,@4
                                 	.endmacro
                                 .macro	SUB3
                                 	sub	@2,@5
                                 	sbc	@1,@4
                                 	sbc	@0,@3
                                 	.endmacro
                                 .macro	SUB2
                                 	sub	@1,@3
                                 	sbc	@0,@2
                                 	.endmacro
                                 	
                                 .macro	CP4			; compare
                                 	cp	@3,@7
                                 	cpc	@2,@6
                                 	cpc	@1,@5
                                 	cpc	@0,@4
                                 	.endmacro
                                 .macro	CP3
                                 	cp	@2,@5
                                 	cpc	@1,@4
                                 	cpc	@0,@3
                                 	.endmacro
                                 .macro	CP2
                                 	cp	@1,@3
                                 	cpc	@0,@2
                                 	.endmacro
                                 
                                 .macro	TST4			; test
                                 	clr	w
                                 	cp	@3,w
                                 	cpc	@2,w
                                 	cpc	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 .macro	TST3
                                 	clr	w
                                 	cp	@2,w
                                 	cpc	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 .macro	TST2
                                 	clr	w
                                 	cp	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 
                                 .macro	ADDI4			; add immediate
                                 	subi	@3,  low(-@4)
                                 	sbci	@2, high(-@4)
                                 	sbci	@1,byte3(-@4)
                                 	sbci	@0,byte4(-@4)
                                 	.endmacro
                                 .macro	ADDI3
                                 	subi	@2,  low(-@3)
                                 	sbci	@1, high(-@3)
                                 	sbci	@0,byte3(-@3)
                                 	.endmacro
                                 .macro	ADDI2
                                 	subi	@1,  low(-@2)
                                 	sbci	@0, high(-@2)
                                 	.endmacro
                                 	
                                 .macro	SUBI4			; subtract immediate
                                 	subi	@3,  low(@4)
                                 	sbci	@2, high(@4)
                                 	sbci	@1,byte3(@4)
                                 	sbci	@0,byte4(@4)
                                 	.endmacro
                                 .macro	SUBI3
                                 	subi	@2,  low(@3)
                                 	sbci	@1, high(@3)
                                 	sbci	@0,byte3(@3)
                                 	.endmacro
                                 .macro	SUBI2
                                 	subi	@1,  low(@2)
                                 	sbci	@0, high(@2)
                                 	.endmacro
                                 
                                 .macro	LSL5			; logical shift left
                                 	lsl	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL4
                                 	lsl	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL3
                                 	lsl	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL2
                                 	lsl	@1
                                 	rol	@0
                                 	.endmacro
                                 	
                                 .macro	LSR4			; logical shift right
                                 	lsr	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	LSR3
                                 	lsr	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	LSR2
                                 	lsr	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	ASR4			; arithmetic shift right
                                 	asr	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	ASR3
                                 	asr	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	ASR2
                                 	asr	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	ROL8			; rotate left through carry
                                 	rol	@7
                                 	rol	@6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL7
                                 	rol	@6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 
                                 .macro	ROR8			; rotate right through carry
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	ror	@6
                                 	ror	@7
                                 	.endmacro
                                 .macro	ROR7
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	ror	@6
                                 	.endmacro
                                 .macro	ROR6
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	.endmacro
                                 .macro	ROR5
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	.endmacro	
                                 .macro	ROR4
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	ROR3
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	ROR2
                                 	ror	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	PUSH2
                                 	push	@0
                                 	push	@1
                                 	.endmacro	
                                 .macro	POP2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro
                                 
                                 .macro	PUSH3
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	.endmacro	
                                 .macro	POP3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro
                                 	
                                 .macro	PUSH4
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	push	@3
                                 	.endmacro	
                                 .macro	POP4
                                 	pop	@3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro	
                                 	
                                 .macro	PUSH5
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	push	@3
                                 	push	@4
                                 	.endmacro	
                                 .macro	POP5
                                 	pop	@4
                                 	pop	@3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro	
                                 
                                 ; --- SRAM operations ---
                                 .macro	INCS4	; sram		; increment SRAM 4-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 	brne	end
                                 	lds	w,@0+2
                                 	inc	w
                                 	sts	@0+2,w
                                 	brne	end
                                 	lds	w,@0+3
                                 	inc	w
                                 	sts	@0+3,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS3	; sram		; increment SRAM 3-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 	brne	end
                                 	lds	w,@0+2
                                 	inc	w
                                 	sts	@0+2,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS2	; sram		; increment SRAM 2-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS	; sram		; increment SRAM 1-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	DECS4	; sram		; decrement SRAM 4-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	lds	u,@0+2
                                 	sbc	u,w
                                 	sts	@0+2,u
                                 	lds	u,@0+3
                                 	sbc	u,w
                                 	sts	@0+3,u
                                 	.endmacro
                                 .macro	DECS3	; sram		; decrement SRAM 3-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	lds	u,@0+2
                                 	sbc	u,w
                                 	sts	@0+2,u
                                 	.endmacro
                                 .macro	DECS2	; sram		; decrement SRAM 2-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	.endmacro
                                 .macro	DECS	; sram		; decrement
                                 	lds	w,@0
                                 	dec	w
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	MOVS4	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	lds	w,@1+2
                                 	sts	@0+2,w
                                 	lds	w,@3+1
                                 	sts	@0+3,w	
                                 	.endmacro
                                 .macro	MOVS3	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	lds	w,@1+2
                                 	sts	@0+2,w
                                 	.endmacro
                                 .macro	MOVS2	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	.endmacro
                                 .macro	MOVS	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	SEXT	; reg1,reg0	; sign extend
                                 	clr	@0
                                 	sbrc	@1,7
                                 	dec	@0
                                 	.endmacro
                                 
                                 ; =======================================
                                 ;	Jump/Call with constant arguments
                                 ; =======================================
                                 	
                                 ; --- calls with arguments a,b,XYZ ---
                                 .macro	CX	; subroutine,x
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CXY	; subroutine,x,y
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	yl, low(@2)
                                 	ldi	yh,high(@2)	
                                 	rcall	@0
                                 	.endmacro		
                                 .macro	CXZ	; subroutine,x,z
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	zl, low(@2)
                                 	ldi	zh,high(@2)	
                                 	rcall	@0
                                 	.endmacro		
                                 .macro	CXYZ	; subroutine,x,y,z
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	yl, low(@2)
                                 	ldi	yh,high(@2)
                                 	ldi	zl, low(@3)
                                 	ldi	zh,high(@3)		
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CW	; subroutine,w
                                 	ldi	w, @1
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CA	; subroutine,a
                                 	ldi	a0, @1
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CAB	; subroutine,a,b
                                 	ldi	a0, @1
                                 	ldi	b0, @2
                                 	rcall	@0
                                 	.endmacro
                                 
                                 ; --- jump with arguments w,a,b ---
                                 .macro	JW	; subroutine,w
                                 	ldi	w, @1
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JA	; subroutine,a
                                 	ldi	a0, @1
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JAB	; subroutine,a,b
                                 	ldi	a0, @1
                                 	ldi	b0, @2
                                 	rjmp	@0
                                 	.endmacro
                                 .list
                                 .include "lib/definitions.asm"
                                 
                                 ; purpose library, definition of addresses and constants
                                 ; 20171114 A.S.
                                 
                                 ; === definitions  ===
                                 .list
                                 
                                 ; ========================interrupt vector tables =================================
                                 .org 0
000000 940c 0024                 		jmp			reset
                                 
                                 .org	OVF0addr
000020 c000                      		rjmp		overflow0
                                 
                                 
                                 ; =========interrupt service routine ==========
                                 	
                                 overflow0:
000021 b61f                      		in			_sreg, SREG					; save context
000022 be1f                      		out			SREG, _sreg					; restore context
000023 9518                      		reti
                                 ; ================== init / reset ===============================
                                 reset:
000024 ef0f
000025 bf0d
000026 e100
000027 bf0e                      		LDSP		RAMEND						; load stack pointer (SP)
                                 		;wdr										; reset watchdog timer
                                 		;ldi			r16, 1<<WDE+0b100			; enable watchdog
                                 		;out			WDTCR, r16
                                 		
000028 d146                      		rcall		LCD_init
000029 d163                      		rcall		encoder_init
00002a d246                      		rcall		wire1_init
                                 		;OUTI		TIMSK, (1<<TOIE0)			;init du timer
                                 		;OUTI		ASSR,  (1<<AS0)
                                 		;OUTI		TCCR0,6
00002b e80e
00002c b906                      		OUTI		ADCSR,(1<<ADEN) + (1<<ADIE) + 6 ;init du ADC pour LDR
00002d e000
00002e b907                      		OUTI		ADMUX, 0						;pin 0 -> LDR
                                 		;OUTI		ADMUX, 1						;pin 1 -> humidity   VERIFIER QUE CA MARCHE COMME CA -- > JE PENSE PAS
00002f e020                      		ldi			a0, 0
                                 		;sei									; set global interrupts
000030 c28e                      		rjmp			main
                                 
                                 .include "lib/printf.asm"
                                 
                                 ; purpose library, formatted output generation
                                 ; author (c) R.Holzer (adapted MICRO210/EE208 A.Schmid)
                                 ; v2019.02 20180821 AxS supports SRAM input from 0x0260
                                 ;					through 0x02ff that should be reserved
                                 
                                 ; === description ===
                                 ; 
                                 ; The program "printf" interprets and prints formatted strings.
                                 ; The special formatting characters regognized are:
                                 ;
                                 ; FDEC	decimal number
                                 ; FHEX	hexadecimal number
                                 ; FBIN	binary number
                                 ; FFRAC	fixed fraction number
                                 ; FCHAR	single ASCII character
                                 ; FSTR	zero-terminated ASCII string
                                 ;	
                                 ; The special formatting characters are distinguished from normal 
                                 ; ASCII characters by having their bit7 set to 1.
                                 ;
                                 ; Signification of bit fields:
                                 ;
                                 ; b 	bytes		1..4 b bytes		2
                                 ; s 	sign		0(unsigned), 1(signed)	1
                                 ; i		integer digits	
                                 ; e 	base		2,,36			5
                                 ; dp 	dec. point	0..32			5
                                 ; $if	i=integer digits,  0=all digits,  1..15 digits 
                                 ;		f=fraction digits, 0=no fraction, 1..15 digits
                                 ;
                                 ; Formatting characters must be followed by an SRAM address (0..ff)
                                 ; that determines the origin of variables that must be printed (if any)
                                 ; FBIN,	sram
                                 ; FHEX,	sram
                                 ; FDEC,	sram
                                 ; FCHAR,sram
                                 ; FSTR,	sram
                                 ;
                                 ; The address 'sram' is a 1-byte constant. It addresses
                                 ; 	 0..1f	registers r0..r31, 
                                 ; 	20..3f	i/o ports, (need to be addressed with an offset of $20)
                                 ;	0x0260..0x02ff	SRAM
                                 ; Variables can be located into register and I/0s, and can also
                                 ; be stored into data SRAM at locations 0x0200 through 0x02ff. Any
                                 ; sram address higher than 0x0060 is assumed to be at (0x0260+address)
                                 ; from automatic address detection in _printf_formatted: and subsequent
                                 ; assignment to xh; xl keeps its value. Consequently, variables that are
                                 ; to be stored into SRAM and further printed by fprint must reside at
                                 ; 0x0200 up to 0x02ff, and must be addressed using a label. Usage: see
                                 ; file string1.asm, for example.
                                 
                                 ; The FFRAC formatting character must be followed by 
                                 ;	ONE sram address and 
                                 ;	TWO more formatting characters
                                 ; FFRAC,sram,dp,$if
                                 
                                 ; dp	decimal point position, 0=right, 32=left
                                 ; $if	format i.f, i=integer digits, f=fraction digits
                                 
                                 ; The special formatting characters use the following coding
                                 ;
                                 ; FDEC	11bb'iiis	i=0 all digits, i=1-7 digits
                                 ; FBIN	101i'iiis	i=0 8 digits,	i=1-7 digits
                                 ; FHEX	1001'iiis	i=0 8 digits,	i=1-7 digits
                                 ; FFRAC	1000'1bbs
                                 ; FCHAR	1000'0100
                                 ; FSTR	1000'0101
                                 ; FREP	1000'0110
                                 ; FFUNC	1000'0111
                                 ;	1000'0010
                                 ;	1000'0011
                                 ; FESC	1000'0000
                                 
                                 ; examples
                                 ; formatting string			printing
                                 ; "a=",FDEC,a,0				1-byte variable a, unsigned decimal
                                 ; "a=",FDEC2,a,0			2-byte variable a (a1,a0), unsigend
                                 ; "a=",FDEC|FSIGN,a,0		1-byte variable 1, signed decimal
                                 ; "n=",FBIN,PIND+$20,0		i/o port, binary, notice offset of $20
                                 ; "f=",FFRAC4|FSIGN,a,16,$88,0	4-byte signed fixed-point fraction
                                 ;				dec.point at 16, 8 int.digits, 8 frac.digits	
                                 ; "f=",FFRAC2,a,16,$18,0		2-byte unsigned fixed-point fraction
                                 ;				dec.point at 16, 1 int.digits, 8 frac.digits	
                                 ; "a=",FDEC|FDIG5|FSIGN,a,0	1-byte variable, 5-digit, decimal, signed
                                 ; "a=",FDEC|FDIG5,a,0		1-byte variable, 5-digit, decimal, unsigned
                                 
                                 ; === registers modified ===
                                 ; e0,e1	used to transmit address of putc routine
                                 ; zh,zl	used as pointer to prog-memory
                                 
                                 ; === constants ==============================================
                                 
                                 .equ	FDEC	= 0b11000000	; 1-byte variable
                                 .equ	FDEC2	= 0b11010000	; 2-byte variable
                                 .equ	FDEC3	= 0b11100000	; 3-byte variable
                                 .equ	FDEC4	= 0b11110000	; 4-byte variable
                                 
                                 .equ	FBIN	= 0b10100000
                                 .equ	FHEX	= 0b10010100	; 1-byte variable
                                 .equ	FHEX2	= 0b10011000	; 2-byte variable
                                 .equ	FHEX3	= 0b10011100	; 3-byte variable
                                 .equ	FHEX4	= 0b10010000	; 4-byte variable
                                 
                                 .equ	FFRAC	= 0b10001000	; 1-byte variable
                                 .equ	FFRAC2	= 0b10001010	; 2-byte variable
                                 .equ	FFRAC3	= 0b10001100	; 3-byte variable
                                 .equ	FFRAC4	= 0b10001110	; 4-byte variable
                                 
                                 .equ	FCHAR	= 0b10000100
                                 .equ	FSTR	= 0b10000101
                                 
                                 .equ	FSIGN	= 0b00000001
                                 
                                 .equ	FDIG1	= 1<<1
                                 .equ	FDIG2	= 2<<1
                                 .equ	FDIG3	= 3<<1	
                                 .equ	FDIG4	= 4<<1
                                 .equ	FDIG5	= 5<<1
                                 .equ	FDIG6	= 6<<1
                                 .equ	FDIG7	= 7<<1
                                 
                                 ; ===macro ====================================================
                                 
                                 .macro	PRINTF			; putc function (UART, LCD...)
                                 	ldi	w, low(@0)		; address of "putc" in e1:d0
                                 	mov	e0,w
                                 	ldi	w,high(@0)
                                 	mov	e1,w
                                 	rcall	_printf
                                 	.endmacro
                                 
                                 ; mod	y,z
                                 
                                 
                                 ; === routines ================================================
                                 
                                 _printf:
000031 91ff
000032 91ef                      	POPZ			; z points to begin of "string"
000033 0fee
000034 1fff                      	MUL2Z			; multiply Z by two, (word ptr -> byte ptr)
000035 93af
000036 93bf                      	PUSHX
                                 		
                                 _printf_read:
000037 95c8                      	lpm				; places prog_mem(Z) into r0 (=c)
000038 9631                      	adiw	zl,1	; increment pointer Z
000039 2000                      	tst	r0			; test for ZERO (=end of string)
00003a f021                      	breq	_printf_end	; char=0 indicates end of ascii string
00003b f04a                      	brmi	_printf_formatted ; bit7=1 indicates formatting character
00003c 2d00                      	mov	w,r0
00003d d017                      	rcall	_putw	; display the character
00003e cff8                      	rjmp	_printf_read	; read next character in the string
                                 	
                                 _printf_end:
00003f 9631                      	adiw	zl,1	; point to the next character
000040 95f6
000041 95e7                      	DIV2Z			; divide by 2 (byte ptr -> word ptr)
000042 91bf
000043 91af                      	POPX
000044 9409                      	ijmp			; return to instruction after "string"
                                 
                                 _printf_formatted:
                                 
                                 ; FDEC	11bb'iiis
                                 ; FBIN	101i'iiis
                                 ; FHEX	1001'iiis
                                 ; FFRAC	1000'1bbs
                                 ; FCHAR	1000'0100
                                 ; FSTR	1000'0101
                                 
000045 fa00                      	bst	r0,0		; store sign in T
000046 2d00                      	mov	w,r0		; store formatting character in w
000047 95c8                      	lpm	
000048 2da0                      	mov	xl,r0		; load x-pointer with SRAM address
000049 36a0                      	cpi	xl,0x60
00004a f010                      	brlo rio_space
                                 dataram_space:		; variable originates from SRAM memory
00004b e0b2                      	ldi	xh,0x02		;>addresses are limited to 0x0260 through 0x02ff
00004c c001                      	rjmp space_detect_end	;>that enables automatic detection of the origin
                                 rio_space:			; variable originates from reg or I/O space 
00004d 27bb                      	clr	xh			; clear high-byte, addresses are 0x0000 through 0x003f (0x005f)
                                 space_detect_end:
00004e 9631                       	adiw	zl,1	; increment pointer Z
                                 
                                 ;	JB1	w,6,_putdec
                                 ;	JB1	w,5,_putbin
                                 ;	JB1	w,4,_puthex
                                 ;	JB1	w,3,_putfrac
00004f 3804
000050 f079                      	JK	w,FCHAR,_putchar
000051 3805
000052 f081                      	JK	w,FSTR ,_putstr
000053 c015                      	rjmp	_putnum
                                 	
000054 cfe2                      	rjmp	_printf_read	
                                 
                                 ; === putc (put character) ===============================
                                 ; in	w	character to put
                                 ;	e1,e0	address of output routine (UART, LCD putc)
                                 _putw:
000055 932f
000056 93ff
000057 93ef                      	PUSH3	a0,zh,zl
000058 2de4
000059 2df5
00005a 2f20                      	MOV3	a0,zh,zl, w,e1,e0
00005b 9509                      	icall			; indirect call to "putc"
00005c 91ef
00005d 91ff
00005e 912f                      	POP3	a0,zh,zl
00005f 9508                      	ret
                                 
                                 ; === putchar (put character) ============================
                                 ; in	x	pointer to character to put
                                 _putchar:
000060 910c                      	ld	w,x
000061 dff3                      	rcall	_putw
000062 cfd4                      	rjmp	_printf_read
                                 	
                                 ; === putstr (put string) ================================
                                 ; in	x	pointer to ascii string
                                 ;	b3,b2	address of output routine (UART, LCD putc)
                                 _putstr:
000063 910d                      	ld	w,x+
000064 2300                      	tst	w
000065 f409                      	brne	PC+2
000066 cfd0                      	rjmp	_printf_read
000067 dfed                      	rcall	_putw
000068 cffa                      	rjmp	_putstr
                                 
                                 ; === putnum (dec/bin/hex/frac) ===========================
                                 ; in	x	pointer to SRAM variable to print
                                 ; 	r0	formatting character
                                 	
                                 _putnum:
000069 935f
00006a 934f
00006b 933f
00006c 932f                      	PUSH4	a3,a2,a1,a0	; safeguard a
00006d 939f
00006e 938f
00006f 937f
000070 936f                      	PUSH4	b3,b2,b1,b0	; safeguard b	
000071 912d
000072 913d
000073 914d
000074 915d                      	LDX4	a3,a2,a1,a0	; load operand to print into a
                                 
                                 ; FDEC	11bb'iiis
                                 ; FBIN	101i'iiis
                                 ; FHEX	1001'iiis
                                 ; FRACT	1000'1bbs
                                 
000075 fd06
000076 c006                      	JB1	w,6,_putdec
000077 fd05
000078 c00f                      	JB1	w,5,_putbin
000079 fd04
00007a c010                      	JB1	w,4,_puthex
00007b fd03
00007c c019                      	JB1	w,3,_putfrac
                                 
                                 ; FDEC	11bb'iiis
                                 _putdec:
00007d e06a                      	ldi	b0,10		; b0 = base (10)
                                 
00007e 2f70                      	mov	b1,w
00007f 9576                      	lsr	b1
000080 7077                      	andi	b1,0b111	
000081 9572                      	swap	b1		; b1 = format 0iii'0000 (integer digits)
000082 e080                      	ldi	b2,0		; b2 = dec. point position = 0 (right)
                                 	
000083 2f90                      	mov	b3,w
000084 9592                      	swap	b3
000085 7093                      	andi	b3,0b11
000086 9593                      	inc	b3			; b3 = number of bytes (1..4)
000087 c01a                      	rjmp	_getnum	; get number of digits (iii)
                                 
                                 ; FBIN	101i'iiis	addr
                                 _putbin:	
000088 e062                      	ldi	b0,2		; b0 = base (2)
000089 e094                      	ldi	b3,4		; b3 = number of bytes (4)	
00008a c003                      	rjmp	_getdig	; get number of digits (iii)
                                 
                                 ; FHEX	1001'iiis	addr
                                 _puthex:	
00008b e160                      	ldi	b0,16		; b0 = base (16)
00008c e094                      	ldi	b3,4		; b3 = number of bytes (4)
00008d c000                      	rjmp	_getdig
                                 
                                 _getdig:
00008e 2f70                      	mov	b1,w
00008f 9576                      	lsr	b1
000090 7077                      	andi	b1,0b111
000091 f409                      	brne	PC+2
000092 e078                      	ldi	b1,8		; if b1=0 then 8-digits
000093 9572                      	swap	b1		; b1 = format 0iii'0000 (integer digits)
000094 e080                      	ldi	b2, 0		; b2 = dec. point position = 0 (right)
000095 c00c                      	rjmp	_getnum
                                 
                                 ; FFRAC	1000'1bbs	addr	 00dd'dddd, 	iiii'ffff
                                 	
                                 _putfrac:
000096 e06a                      	ldi	b0,10		; base=10	
000097 95c8                      	lpm
000098 2d80                      	mov	b2,r0		; load dec.point position
000099 9631                      	adiw	zl,1	; increment char pointer
00009a 95c8                      	lpm
00009b 2d70                      	mov	b1,r0		; load ii.ff format
00009c 9631                      	adiw	zl,1	; increment char pointer
                                 	
00009d 2f90                      	mov	b3,w
00009e 9595                      	asr	b3
00009f 7093                      	andi	b3,0b11
0000a0 9593                      	inc	b3			; b3 = number of bytes (1..4)
                                 
0000a1 c000                      	rjmp	_getnum
                                 
                                 _getnum:
                                 ; in 	a	4-byte variable
                                 ; 	b3	number of bytes (1..4)
                                 ;	T	sign, 0=unsigned, 1=signed
                                 
0000a2 3094
0000a3 f081                      	JK	b3,4,_printf_4b
0000a4 3093
0000a5 f051                      	JK	b3,3,_printf_3b
0000a6 3092
0000a7 f021                      	JK	b3,2,_printf_2b	
                                 	
                                 _printf_1b:			; sign extension
0000a8 2733                      	clr	a1
0000a9 f416                      	brtc	PC+3	; T=1 sign extension
0000aa fd27                      	sbrc	a0,7
0000ab ef3f                      	ldi	a1,0xff
                                 _printf_2b:
0000ac 2744                      	clr	a2
0000ad f416                      	brtc	PC+3	; T=1 sign extension	
0000ae fd37                      	sbrc	a1,7
0000af ef4f                      	ldi	a2,0xff
                                 _printf_3b:	
0000b0 2755                      	clr	a3
0000b1 f416                      	brtc	PC+3	; T=1 sign extension
0000b2 fd47                      	sbrc	a2,7
0000b3 ef5f                      	ldi	a3,0xff
                                 _printf_4b:
                                 
0000b4 d009                      	rcall	_ftoa		; float to ascii
0000b5 916f
0000b6 917f
0000b7 918f
0000b8 919f                      	POP4	b3,b2,b1,b0	; restore b
0000b9 912f
0000ba 913f
0000bb 914f
0000bc 915f                      	POP4	a3,a2,a1,a0	; restore a
                                 	
0000bd cf79                      	rjmp	_printf_read
                                 
                                 ; ===============================================
                                 ; func	ftoa
                                 ; converts a fixed-point fractional number to an ascii string
                                 ; author (c) Raphael Holzer
                                 ;
                                 ; in	a3-a0	variable to print
                                 ;	b0	base, 2 to 36, but usually decimal (10)
                                 ;	b1	number of digits to print ii.ff
                                 ; 	b2	position of the decimal point (0=right, 32=left)
                                 ;	T	sign (T=0 unsiged, T=1 signed)
                                 
                                 _ftoa:
0000be 92cf                      	push	d0
0000bf 92bf
0000c0 92af
0000c1 929f
0000c2 928f                      	PUSH4	c3,c2,c1,c0	; c = fraction part, a = integer part
0000c3 18bb
0000c4 24aa
0000c5 2499
0000c6 2488                      	CLR4	c3,c2,c1,c0	; clear fraction part
                                 
0000c7 f486                      	brtc	_ftoa_plus	; if T=0 then unsigned
0000c8 94e8                      	clt
0000c9 2355                      	tst	a3				; if MSb(a)=1 then a=-a
0000ca f46a                      	brpl	_ftoa_plus
0000cb 9468                      	set					; T=1 (minus)
0000cc 2377                      	tst	b1
0000cd f009                      	breq	PC+2		; if b1=0 the print ALL digits
0000ce 5170                      	subi	b1,0x10		; decrease int digits
0000cf 9550
0000d0 9540
0000d1 9530
0000d2 9520
0000d3 ef0f
0000d4 1b20
0000d5 0b30
0000d6 0b40
0000d7 0b50                      	NEG4	a3,a2,a1,a0	; negate a
                                 _ftoa_plus:	
0000d8 2388                      	tst	b2				; b0=0 (only integer part)
0000d9 f051                      	breq	_ftoa_int	
                                 _ftoa_shift:	
0000da 9555
0000db 9547
0000dc 9537
0000dd 9527                      	ASR4	a3,a2,a1,a0	; a = integer part	
0000de 94b7
0000df 94a7
0000e0 9497
0000e1 9487                      	ROR4	c3,c2,c1,c0	; c = fraction part
0000e2 958a
0000e3 f7b1                      	DJNZ	b2,_ftoa_shift
                                 _ftoa_int:
0000e4 937f                      	push	b1			; ii.ff (ii=int digits)
0000e5 9572                      	swap	b1
0000e6 707f                      	andi	b1,0x0f
                                 	
0000e7 e20e                      	ldi	w,'.'			; push decimal point
0000e8 930f                      	push	w
                                 _ftoa_int1:
0000e9 d045                      	rcall	_div41		; int=int/10
0000ea 2d0c                      	mov	w,d0			; d=reminder
0000eb d030                      	rcall	_hex2asc
0000ec 930f                      	push	w			; push rem(int/10)
0000ed 2700
0000ee 1720
0000ef 0730
0000f0 0740
0000f1 0750                      	TST4	a3,a2,a1,a0	; (int/10)=?
0000f2 f029                      	breq	_ftoa_space	; (int/10)=0 then finished
0000f3 2377                      	tst	b1
0000f4 f3a1                      	breq	_ftoa_int1	; if b1=0 then print ALL int-digits
0000f5 957a
0000f6 f791                      	DJNZ	b1,_ftoa_int1
0000f7 c007                      	rjmp	_ftoa_sign
                                 _ftoa_space:
0000f8 2377                      	tst	b1				; if b1=0 then print ALL int-digits
0000f9 f029                      	breq	_ftoa_sign
0000fa 957a                      	dec	b1
0000fb f019                      	breq	_ftoa_sign
0000fc e200                      	ldi	w,' '			; write spaces
0000fd df57                      	rcall	_putw	
0000fe cff9                      	rjmp	_ftoa_space
                                 _ftoa_sign:
0000ff f416                      	brtc	PC+3		; if T=1 then write 'minus'
000100 e20d                      	ldi	w,'-'
000101 df53                      	rcall	_putw
                                 _ftoa_int3:
000102 910f                      	pop	w
000103 320e                      	cpi	w,'.'
000104 f011                      	breq	PC+3
000105 df4f                      	rcall	_putw
000106 cffb                      	rjmp	_ftoa_int3
                                 
000107 917f                      	pop	b1				; ii.ff (ff=frac digits)
000108 707f                      	andi	b1,0x0f
000109 2377                      	tst	b1
00010a f059                      	breq	_ftoa_end
                                 _ftoa_point:	
00010b df49                      	rcall	_putw		; write decimal point
00010c 2d28
00010d 2d39
00010e 2d4a
00010f 2d5b                      	MOV4	a3,a2,a1,a0, c3,c2,c1,c0		
                                 _ftoa_frac:
000110 d011                      	rcall	_mul41		; d.frac=10*frac
000111 2d0c                      	mov	w,d0
000112 d009                      	rcall	_hex2asc
000113 df41                      	rcall	_putw
000114 957a
000115 f7d1                      	DJNZ	b1,_ftoa_frac
                                 _ftoa_end:
000116 908f
000117 909f
000118 90af
000119 90bf                      	POP4	c3,c2,c1,c0
00011a 90cf                      	pop	d0
00011b 9508                      	ret
                                 
                                 ; === hexadecimal to ascii ===
                                 ; in	w
                                 _hex2asc:
00011c 300a                      	cpi	w,10
00011d f410                      	brsh	PC+3
00011e 5d00                      	addi	w,'0'
00011f 9508                      	ret
000120 5a09                      	addi	w,('a'-10)
000121 9508                      	ret
                                 
                                 ; === multiply 4byte*1byte ===
                                 ; funct mul41
                                 ; multiplies a3-a0 (4-byte) by b0 (1-byte)
                                 ; author (c) Raphael Holzer, EPFL
                                 ; 
                                 ; in	a3..a0	multiplicand (argument to multiply)
                                 ;	b0	multiplier
                                 ; out	a3..a0	result
                                 ; 	d0	result MSB (byte 4)
                                 ;
000122 24cc                      _mul41:	clr	d0			; clear byte4 of result
000123 e200                      	ldi	w,32			; load bit counter
000124 9488                      __m41:	clc				; clear carry
000125 fd20                      	sbrc	a0,0		; skip addition if LSB=0
000126 0ec6                      	add	d0,b0			; add b to MSB of a
000127 94c7
000128 9557
000129 9547
00012a 9537
00012b 9527                      	ROR5	d0,a3,a2,a1,a0	; shift-right c, LSB (of b) into carry
00012c 950a
00012d f7b1                      	DJNZ	w,__m41		; Decrement and Jump if bit-count Not Zero
00012e 9508                      	ret
                                 
                                 ; === divide 4byte/1byte ===
                                 ; func div41
                                 ; in	a0..a3 	divident (argument to divide)
                                 ;	b0 	divider
                                 ; out	a0..a3 	result 
                                 ;	d0	reminder
                                 ;
00012f 24cc                      _div41:	clr	d0			; d will contain the remainder
000130 e200                      	ldi	w,32			; load bit counter
000131 1f22
000132 1f33
000133 1f44
000134 1f55
000135 1ccc                      __d41:	ROL5	d0,a3,a2,a1,a0	; shift carry into result c
000136 1ac6                      	sub	d0, b0			; subtract b from remainder
000137 f408                      	brcc	PC+2	
000138 0ec6                      	add	d0, b0			; restore if remainder became negative
000139 950a
00013a f7b1                      	DJNZ	w,__d41		; Decrement and Jump if bit-count Not Zero
00013b 1f22
00013c 1f33
00013d 1f44
00013e 1f55                      	ROL4	a3,a2,a1,a0	; last shift (carry into result c)
00013f 9550
000140 9540
000141 9530
000142 9520                      	COM4	a3,a2,a1,a0	; complement result
000143 9508                      	ret
                                 .include "lib/lcd.asm"
                                 
                                 ; purpose  LCD HD44780U library
                                 ; ATmega 128 and Atmel Studio 7.0 compliant
                                 
                                 ; === definitions ===
                                 .equ	LCD_IR	= 0x8000	; address LCD instruction reg
                                 .equ	LCD_DR	= 0xc000	; address LCD data register
                                 
                                 ; === subroutines ===
                                 LCD_wr_ir:
                                 ; in	w (byte to write to LCD IR)
000144 9030 8000                 	lds	u, LCD_IR		; read IR to check busy flag  (bit7)
000146 fc37
000147 cffc                      	JB1	u,7,LCD_wr_ir	; Jump if Bit=1 (still busy)
000148 d003                      	rcall	lcd_4us		; delay to increment DRAM addr counter
000149 9300 8000                 	sts	LCD_IR, w		; store w in IR
00014b 9508                      	ret
                                 	
                                 lcd_4us:
00014c d000                      	rcall	lcd_2us		; recursive call		
                                 lcd_2us:
00014d 0000                      	nop					; rcall(3) + nop(1) + ret(4) = 8 cycles (2us)
00014e 9508                      	ret
                                 
                                 LCD:
                                 LCD_putc:
00014f 302d
000150 f169                      	JK	a0,CR,LCD_cr	; Jump if a0=CR
000151 302a
000152 f1a9                      	JK	a0,LF,LCD_lf	; Jump if a0=LF
                                 LCD_wr_dr:
                                 ; in	a0 (byte to write to LCD DR)
000153 9100 8000                 	lds	w, LCD_IR		; read IR to check busy flag  (bit7)
000155 fd07
000156 cffc                      	JB1	w,7,LCD_wr_dr	; Jump if Bit=1 (still busy)
000157 dff4                      	rcall	lcd_4us		; delay to increment DRAM addr counter
000158 9320 c000                 	sts	LCD_DR, a0		; store a0 in DR
00015a 9508                      	ret	
                                 	
00015b e001
00015c cfe7                      LCD_clear:		JW	LCD_wr_ir, 0b00000001		; clear display
00015d e002
00015e cfe5                      LCD_home:		JW	LCD_wr_ir, 0b00000010		; return home
00015f e100
000160 cfe3                      LCD_cursor_left:	JW	LCD_wr_ir, 0b00010000	; move cursor to left
000161 e104
000162 cfe1                      LCD_cursor_right:	JW	LCD_wr_ir, 0b00010100	; move cursor to right
000163 e108
000164 cfdf                      LCD_display_left:	JW	LCD_wr_ir, 0b00011000	; shifts display to left
000165 e10c
000166 cfdd                      LCD_display_right:	JW	LCD_wr_ir, 0b00011100	; shifts display to right
000167 e00d
000168 cfdb                      LCD_blink_on:		JW	LCD_wr_ir, 0b00001101	; Display=1,Cursor=0,Blink=1
000169 e00c
00016a cfd9                      LCD_blink_off:		JW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0
00016b e00e
00016c cfd7                      LCD_cursor_on:		JW	LCD_wr_ir, 0b00001110	; Display=1,Cursor=1,Blink=0
00016d e00c
00016e cfd5                      LCD_cursor_off:		JW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0
                                 		
                                 LCD_init:
00016f b705                      	in	w,MCUCR					; enable access to ext. SRAM
000170 6c00                      	sbr	w,(1<<SRE)+(1<<SRW10)
000171 bf05                      	out	MCUCR,w
000172 e001
000173 dfd0                      	CW	LCD_wr_ir, 0b00000001	; clear display
000174 e006
000175 dfce                      	CW	LCD_wr_ir, 0b00000110	; entry mode set (Inc=1, Shift=0)
000176 e00c
000177 dfcc                      	CW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0	
000178 e308
000179 dfca                      	CW	LCD_wr_ir, 0b00111000	; 8bits=1, 2lines=1, 5x8dots=0
00017a 9508                      	ret
                                 
                                 LCD_pos:
                                 ; in	a0 = position (0x00..0x0f first line, 0x40..0x4f second line)
00017b 2f02                      	mov	w,a0
00017c 6800                      	ori	w,0b10000000
00017d cfc6                      	rjmp	LCD_wr_ir
                                 
                                 LCD_cr:
                                 ; moving the cursor to the beginning of the line (carriage return)
00017e 9100 8000                 	lds	w, LCD_IR			; read IR to check busy flag  (bit7)
000180 fd07
000181 cffc                      	JB1	w,7,LCD_cr			; Jump if Bit=1 (still busy)
000182 7400                      	andi	w,0b01000000	; keep bit6 (begin of line 1/2)
000183 6800                      	ori	w,0b10000000		; write address command
000184 dfc7                      	rcall	lcd_4us			; delay to increment DRAM addr counter
000185 9300 8000                 	sts	LCD_IR,w			; store in IR
000187 9508                      	ret
                                 
                                 LCD_lf:
                                 ; moving the cursor to the beginning of the line 2 (line feed)
000188 932f                      	push	a0				; safeguard a0
000189 e420                      	ldi	a0,$40				; load position $40 (begin of line 2)
00018a dff0                      	rcall	LCD_pos			; set cursor position
00018b 912f                      	pop	a0					; restore a0
                                 .include "lib/encoder.asm"
00018c 9508                      
                                 ; purpose library angular encoder operation
                                 
                                 ; === definitions ===
                                 .equ	ENCOD	= PORTE
                                 
                                 .dseg
000100                           enc_old:.byte	1
                                 .cseg
                                 
                                 ; === routines ===
                                 
                                 encoder_init:
00018d b102                      	in	w,ENCOD-1		; make 3 lines input
00018e 780f                      	andi	w,0b10001111
00018f b902                      	out	ENCOD-1,w
000190 b103                      	in	w,ENCOD			; enable 3 internal pull-ups
000191 6700                      	ori	w,0b01110000
000192 b903                      	out	ENCOD,w
000193 9508                      	ret
                                 
                                 encoder:
                                 ; a0,b0	if button=up   then increment/decrement a0	 
                                 ; a0,b0	if button=down then incremnt/decrement b0 
                                 ; T 	T=1 button press (transition up-down)
                                 ; Z	Z=1 button down change
                                 
000194 94e8                      	clt						; preclear T
000195 b111                      	in	_w,ENCOD-2			; read encoder port (_w=new)
                                 	
000196 7710                      	andi	_w,0b01110000	; mask encoder lines (A,B,I)
000197 9020 0100                 	lds	_u,enc_old			; load prevous value (_u=old)
000199 1512                      	cp	_w,_u				; compare new<>old ?
00019a f411                      	brne	PC+3
00019b 9498                      	clz
00019c 9508                      	ret						; if new=old then return (Z=0)
00019d 9310 0100                 	sts	enc_old,_w			; store encoder value for next time
                                 
00019f 2621                      	eor	_u,_w				; exclusive or detects transitions
0001a0 9498                      	clz						; clear Z flag
0001a1 fc26                      	sbrc	_u,ENCOD_I
0001a2 c01a                      	rjmp	encoder_button	; transition on I (button)
0001a3 fe24                      	sbrs	_u,ENCOD_A
0001a4 9508                      	ret						; return (no transition on I or A)	
                                 
0001a5 ff16                      	sbrs	_w,ENCOD_I		; is the button up or down ?
0001a6 c00b                      	rjmp	i_down
                                 i_up:	
0001a7 fd14                      	sbrc	_w,ENCOD_A
0001a8 c004                      	rjmp	a_rise
                                 a_fall:
0001a9 9523                      	inc	a0					; if B=1 then increment
0001aa ff15                      	sbrs	_w,ENCOD_B
0001ab 5022                      	subi	a0,2			; if B=0 then decrement
0001ac c003                      	rjmp	i_up_done
                                 a_rise:
0001ad 9523                      	inc	a0					; if B=0 then increment
0001ae fd15                      	sbrc	_w,ENCOD_B
0001af 5022                      	subi	a0,2			; if B=1 then decrement
                                 i_up_done:
0001b0 9498                      	clz						; clear Z
0001b1 9508                      	ret
                                 
                                 i_down:	
0001b2 fd14                      	sbrc	_w,ENCOD_A
0001b3 c004                      	rjmp	a_rise2
                                 a_fall2:
0001b4 9563                      	inc	b0					; if B=1 then increment
0001b5 ff15                      	sbrs	_w,ENCOD_B
0001b6 5062                      	subi	b0,2			; if B=0 then decrement
0001b7 c003                      	rjmp	i_down_done
                                 a_rise2:
0001b8 9563                      	inc	b0					; if B=0 then increment
0001b9 fd15                      	sbrc	_w,ENCOD_B
0001ba 5062                      	subi	b0,2			; if B=1 then decrement
                                 i_down_done:
0001bb 9418                      	sez						; set Z
0001bc 9508                      	ret
                                 
                                 encoder_button:
0001bd fd16                      	sbrc	_w,ENCOD_I
0001be c002                      	rjmp	i_rise
                                 i_fall:
0001bf 9468                      	set						; set T=1 to indicate button press
0001c0 9508                      	ret
                                 i_rise:
0001c1 9508                      	ret
                                 
                                 .macro	CYCLIC	;reg,lo,hi
                                 	cpi	@0,@1-1
                                 	brne	PC+2
                                 	ldi	@0,@2
                                 	cpi	@0,@2+1
                                 	brne	PC+2
                                 	ldi	@0,@1
                                 .endmacro
                                 .include "lib/menu.asm"	
                                 
                                 ; purpose library, menu usage
                                 
                                 menu:
                                 ; in	a0	menu item (0..n)
                                 ; 		z	pointer to menu string "item0|item1..item_n"
                                 
0001c2 932f                      	push	a0				; safeguard a0
0001c3 2322                      	tst		a0					; if a0=0 then print first item
0001c4 f039                      	breq	menu_print		
                                 menu_find:
0001c5 95c8                      	lpm
0001c6 2d00                      	mov	w,r0
0001c7 9631                      	adiw	zl,1
0001c8 370c                      	cpi	w,'|'
0001c9 f7d9                      	brne	PC-4			; inner loop finds the '|'
0001ca 952a                      	dec	a0		
0001cb f7c9                      	brne	PC-6			; outer loop counts down to zero
                                 
                                 menu_print:
0001cc 95c8                      	lpm						; print the item	
0001cd 2d20                      	mov	a0,r0
0001ce 372c                      	cpi	a0,'|'
0001cf f029                      	breq	menu_done		; if char='|' then end of item
0001d0 3020                      	cpi	a0,0
0001d1 f019                      	breq	menu_done		; if char=0 (NUL) then end of string
0001d2 9631                      	adiw	zl,1
0001d3 df7b                      	rcall	lcd_putc		; put the character and continue
0001d4 cff7                      	rjmp	menu_print
                                 menu_done:
0001d5 95c8                      	lpm
0001d6 9631                      	adiw	zl,1
0001d7 2000                      	tst	r0
0001d8 f7e1                      	brne	menu_done		; advance pointer z beyond end of string
0001d9 912f                      	pop	a0					; restore register a0
0001da 9508                      	ret
                                 
                                 ; === menu immediate ===
                                 menui:
0001db 91ff
0001dc 91ef                      	POPZ					; the return address points to begin of string
0001dd 0fee
0001de 1fff                      	MUL2Z					; transform word->byte counter
0001df dfe2                      	rcall	menu			; call the menu routine
0001e0 9631                      	adiw	zl,1			; increment pointer once more
0001e1 95f6
0001e2 95e7                      	DIV2Z					; transform byte->word counter
                                 .include "lib/eeprom.asm"
0001e3 9409                      
                                 ; purpose library, internal EEPROM
                                 
                                 eeprom_store:
                                 ; in:	xh:xl 	EEPROM address
                                 ;	a0	EEPROM data byte to store
                                 
0001e4 99e1                      	sbic	EECR,EEWE	; skip if EEWE=0 (wait it EEWE=1)
0001e5 cffe                      	rjmp	PC-1		; jump back to previous address
0001e6 bbae                      	out	EEARL,xl		; load EEPROM address low	
0001e7 bbbf                      	out	EEARH,xh		; load EEPROM address high
0001e8 bb2d                      	out	EEDR,a0			; set EEPROM data register
0001e9 f01f                      	brie	eeprom_cli	; if I=1 then temporarily disable interrupts
0001ea 9ae2                      	sbi	EECR,EEMWE		; set EEPROM Master Write Enable
0001eb 9ae1                      	sbi	EECR,EEWE		; set EEPROM Write Enable
0001ec 9508                      	ret	
                                 eeprom_cli:
0001ed 94f8                      	cli					; disable interrupts
0001ee 9ae2                      	sbi	EECR,EEMWE		; set EEPROM Master Write Enable
0001ef 9ae1                      	sbi	EECR,EEWE		; set EEPROM Write Enable
0001f0 9478                      	sei					; enable interrupts
0001f1 9508                      	ret
                                 
                                 eeprom_load:
                                 ; in:	xh:xl 	EEPROM address
                                 ; out:	a0	EEPROM data byte to load
                                 
0001f2 99e1                      	sbic	EECR,EEWE	; skip if EEWE=0 (wait it EEWE=1)
0001f3 cffe                      	rjmp	PC-1		; jump back to previous address
0001f4 bbae                      	out	EEARL,xl	
0001f5 bbbf                      	out	EEARH,xh
0001f6 9ae0                      	sbi	EECR,EERE		; set EEPROM Read Enable
0001f7 b32d                      	in	a0,EEDR			; read data register of EEPROM
0001f8 9508                      	ret
                                 
                                 record:
0001f9 2f02                      	mov			w,a0					; garder la valeur a0 avant de la perdre dans eeprom_store
0001fa 2f23                      	mov			a0, a1					; transfer pour que eeprom_store prenne le MSB de la temperature
0001fb dfe8                      	rcall		eeprom_store			; stockage du LSB de la temperature
0001fc 9611                      	adiw		xl,1					; incrementation de l'adresse de la eeprom
0001fd 2f20                      	mov			a0, w
0001fe dfe5                      	rcall		eeprom_store			; stockage du MSB de la temperature
0001ff 9611                      	adiw		xl,1					; incrementation de l'adresse de la eeprom
000200 ec08
000201 2e30
000202 e001
000203 930f
000204 923f
000205 e300
000206 2e30
000207 e006
000208 943a
000209 f7f1
00020a 943a
00020b 950a
00020c f7d9
00020d 903f
00020e 910f
00020f 943a
000210 f791
000211 950a
000212 f781                      	WAIT_MS		200 ;POSE PROBLEME DANS LA IRS???????????
000213 9508                      	ret
                                 
                                 ;.include "lib/wire1.asm"
                                 
                                 .include "libPerso/per_sensors.asm"
                                 
                                 
                                 ; ==========================macros =====================================
                                 	
                                 ; =======================subroutine=========================
                                 temperature:		;PORT B
                                 		
000214 d05f                      		rcall		wire1_reset							;reset pulse
000215 ec2c
000216 d089                      		CA			wire1_write, skipROM				;skip ROM identification
000217 e424
000218 d087                      		CA			wire1_write, convertT				;initaite temperature convertion
000219 e00a
00021a 2e30
00021b e001
00021c 930f
00021d 923f
00021e e300
00021f 2e30
000220 e006
000221 943a
000222 f7f1
000223 943a
000224 950a
000225 f7d9
000226 903f
000227 910f
000228 943a
000229 f791
00022a 950a
00022b f781                      		WAIT_MS		10					
00022c d047                      		rcall		wire1_reset
00022d ec2c
00022e d071                      		CA			wire1_write, skipROM
00022f eb2e
000230 d06f                      		CA			wire1_write, readScratchpad
000231 d079                      		rcall		wire1_read							;read temperature LSB
000232 2f86                      		mov			b2,b0
000233 d077                      		rcall		wire1_read							;read temperature MSB
000234 2f76                      		mov			b1, b0
000235 2f68                      		mov			b0, b2
000236 9508                      		ret
                                 
                                 light:										;PORT F, pin 0	
                                 		;clr			r23						; stocke l'info dans a1-a0
000237 9a36                      		sbi			ADCSR,ADSC
000238 9936
000239 cffe                      		WP1			ADCSR,ADSC
00023a b164                      		in			b0,ADCL
00023b b175                      		in			b1,ADCH
00023c ec08
00023d 2e30
00023e e001
00023f 930f
000240 923f
000241 e300
000242 2e30
000243 e006
000244 943a
000245 f7f1
000246 943a
000247 950a
000248 f7d9
000249 903f
00024a 910f
00024b 943a
00024c f791
00024d 950a
00024e f781                      		WAIT_MS		200
00024f 9508                      		ret
                                 
                                 humidity:										;PORT F, pin 1
                                 		;clr			r23						; stocke l'info dans a1-a0
000250 9a36                      		sbi			ADCSR,ADSC
000251 9936
000252 cffe                      		WP1			ADCSR,ADSC
000253 b164                      		in			b0,ADCL
000254 b175                      		in			b1,ADCH
000255 ec08
000256 2e30
000257 e001
000258 930f
000259 923f
00025a e300
00025b 2e30
00025c e006
00025d 943a
00025e f7f1
00025f 943a
000260 950a
000261 f7d9
000262 903f
000263 910f
000264 943a
000265 f791
000266 950a
000267 f781                      		WAIT_MS		200
000268 9508                      		ret
                                 .include "libPerso/per_wire1.asm"
                                 
                                 ; purpose Dallas 1-wire(R) interface library
                                 
                                 ; === definitions ===
                                 .equ	DQ_port	= PORTB
                                 .equ	DQ_pin	= DQ
                                 
                                 .equ	DS18B20		= 0x28
                                 
                                 .equ	readROM		= 0x33
                                 .equ	matchROM	= 0x55
                                 .equ	skipROM		= 0xcc
                                 .equ	searchROM	= 0xf0
                                 .equ	alarmSearch	= 0xec
                                 
                                 .equ	writeScratchpad	= 0x4e
                                 .equ	readScratchpad	= 0xbe
                                 .equ	copyScratchpad	= 0x48
                                 .equ	convertT	= 0x44
                                 .equ	recallE2	= 0xb8
                                 .equ	readPowerSupply	= 0xb4
                                 
                                 ; === routines ===
                                 
                                 .macro	WIRE1	; t0,t1,t2
                                 	sbi	DQ_port-1,DQ_pin	; pull DQ low (DDR=1 output)
                                 	ldi	w,(@0+1)/2	
                                 	rcall	wire1_wait		; wait low time (t0)
                                 	cbi	DQ_port-1,DQ_pin	; release DQ (DDR=0 input)
                                 	ldi	w,(@1+1)/2	
                                 	rcall	wire1_wait		; wait high time (t1)
                                 	in	w,DQ_port-2			; sample line (PINx=PORTx-2)
                                 	bst	w,DQ_pin			; store result in T
                                 	ldi	w,(@2+1)/2	
                                 	rcall	wire1_wait		; wait separation time (t2)
                                 	ret
                                 	.endmacro	
                                 
                                 wire1_wait:
000269 950a                      	dec	w					; loop time 2usec
00026a 0000                      	nop
00026b 0000                      	nop
00026c 0000                      	nop
00026d 0000                      	nop
00026e 0000                      	nop
00026f f7c9                      	brne	wire1_wait
000270 9508                      	ret
                                 
                                 wire1_init:
000271 98c5                      	cbi	DQ_port,  DQ_pin	; PORT=0 low (for pull-down)
000272 98bd                      	cbi	DQ_port-1,DQ_pin	; DDR=0 (input hi Z)
000273 9508                      	ret
                                 	
000274 9abd
000275 ef00
000276 dff2
000277 98bd
000278 e203
000279 dfef
00027a b306
00027b fb05
00027c ec0d
00027d dfeb
00027e 9508                      wire1_reset:	WIRE1	480,70,410
00027f 9abd
000280 e10c
000281 dfe7
000282 98bd
000283 e002
000284 dfe4
000285 b306
000286 fb05
000287 e001
000288 dfe0
000289 9508                      wire1_write0:	WIRE1	56,4,1
00028a 9abd
00028b e001
00028c dfdc
00028d 98bd
00028e e10e
00028f dfd9
000290 b306
000291 fb05
000292 e001
000293 dfd5
000294 9508                      wire1_write1:	WIRE1	1,59,1
000295 9abd
000296 e001
000297 dfd1
000298 98bd
000299 e007
00029a dfce
00029b b306
00029c fb05
00029d e107
00029e dfca
00029f 9508                      wire1_read1:	WIRE1	1,14,45
                                 	
                                 wire1_write:
0002a0 937f                      	push	b1
0002a1 e078                      	ldi		b1,8
0002a2 9567                      	ror		b0
                                 
0002a3 f410                      	brcc	PC+3				; if C=1 then wire1, else wire0
0002a4 dfe5                      	rcall	wire1_write1
0002a5 c001                      	rjmp	PC+2
0002a6 dfd8                      	rcall	wire1_write0
                                 
0002a7 957a
0002a8 f7c9                      	DJNZ	b1,wire1_write+2	; dec and jump if not zero
0002a9 917f                      	pop		b1	
0002aa 9508                      	ret
                                 
                                 wire1_read:
0002ab 937f                      	push	b1
0002ac e078                      	ldi		b1,8
0002ad 9567                      	ror		b0
0002ae dfe6                      	rcall	wire1_read1			; returns result in T
0002af f967                      	bld		b0,7					; move T to MSb
0002b0 957a
0002b1 f7d9                      	DJNZ	b1,wire1_read+2		; dec and jump if not zero
0002b2 917f                      	pop		b1	
0002b3 9508                      	ret
                                 	
                                 wire1_crc:
0002b4 e109                      	ldi	w,0b00011001
0002b5 e088                      	ldi	b2,8
0002b6 9567                      crc1:	ror	b0
0002b7 f408                      	brcc	PC+2
0002b8 2770                      	eor	b1,w
0002b9 fb70                      	bst	b1,0
0002ba 9577                      	ror	b1
0002bb f977                      	bld	b1,7
0002bc 958a
0002bd f7c1                      	DJNZ	b2,crc1
0002be 9508                      
                                 main:	
0002bf 3f2f
0002c0 f409
0002c1 e022
0002c2 3023
0002c3 f409
0002c4 e020                      		CYCLIC			a0,0,2
0002c5 e40f
0002c6 2e40
0002c7 e001
0002c8 2e50
0002c9 dd67                      		PRINTF			LCD
0002ca 0d0d
0002cb 1294
C:\Users\Administrateur\Desktop\MCUs-BA4\Projet\Projet\main.asm(51): warning: .cseg .db misalignment - padding zero byte
0002cc 0000                      .db		CR, CR, FHEX,a,0
0002cd df0d                      		rcall			menui
0002ce 6554
0002cf 706d
0002d0 7265
0002d1 7461
0002d2 7275
0002d3 7c65
0002d4 7548
0002d5 696d
0002d6 6964
0002d7 7974
0002d8 2020
0002d9 7c20
0002da 694c
0002db 6867
0002dc 2074
0002dd 2020
0002de 2020
0002df 0020                      .db		"Temperature|Humidity   |Light      ",0		
0002e0 e001
0002e1 2e30
0002e2 e001
0002e3 930f
0002e4 923f
0002e5 e300
0002e6 2e30
0002e7 e006
0002e8 943a
0002e9 f7f1
0002ea 943a
0002eb 950a
0002ec f7d9
0002ed 903f
0002ee 910f
0002ef 943a
0002f0 f791
0002f1 950a
0002f2 f781                      		WAIT_MS			1
0002f3 dea0                      		rcall			encoder
0002f4 f00e                      		brts			mesurements_choice			
0002f5 cfc9                      		rjmp			main
                                 
                                 mesurements_choice:				; switch case selon le choix du menu (-> a0) pour l'affichage de la mesure
0002f6 de64                      		rcall		LCD_clear
0002f7 e000                      		ldi			w, 0x0000		;Temperature code
0002f8 1720                      		cp			a0,w
0002f9 f039                      		breq		getTemp
0002fa e001                      		ldi			w, 0x0001		;Humidity code
0002fb 1720                      		cp			a0,w
0002fc f0a1                      		breq		getHum
0002fd e002                      		ldi			w, 0x0002
0002fe 1720                      		cp			a0,w
0002ff f109                      		breq		getLight
000300 cff5                      		rjmp		mesurements_choice
                                 
                                 
                                 getTemp:
000301 df12                      	rcall		temperature
000302 de5a                      	rcall		lcd_home
000303 e40f
000304 2e40
000305 e001
000306 2e50
000307 dd29                      	PRINTF		LCD
000308 6574
000309 206d
00030a 168b
00030b 4204
00030c 4320
00030d 000d                      .db	"tem ",FFRAC2+FSIGN,b,4,$42," C",CR,0
00030e de85                      	rcall		encoder
00030f f11e                      	brts		come_back
000310 cff0                      	rjmp		getTemp
                                 
                                 getHum:
000311 df3e                      	rcall		humidity
000312 de4a                      	rcall		lcd_home
000313 e40f
000314 2e40
000315 e001
000316 2e50
000317 dd19                      	PRINTF		LCD
000318 7568
000319 206d
00031a 168b
00031b 4204
00031c 2520
00031d 000d                      .db	"hum ",FFRAC2+FSIGN,b,4,$42," %",CR,0
00031e de75                      	rcall		encoder
00031f f09e                      	brts		come_back
000320 cff0                      	rjmp		getHum
                                 
                                 getLight:
000321 df15                      	rcall		light
000322 e40f
000323 2e40
000324 e001
000325 2e50
000326 dd0a                      	PRINTF		LCD
000327 696c
000328 6867
000329 2074
00032a 8b20
00032b 0416
00032c 2042
00032d 6d6c
00032e 2020
00032f 000d                      .db	"light  ",FFRAC2+FSIGN,b,4,$42," lm  ",CR,0
000330 de63                      	rcall		encoder
000331 f00e                      	brts		come_back
000332 cfee                      	rjmp		getLight
                                 
                                 
                                 come_back:
000333 e020                      	ldi			a0, 0
000334 de26                      	rcall		lcd_clear
000335 cf89                      	rjmp		main
                                 
                                 	
                                 	
                                 
                                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega128" register use summary:
x  :   6 y  :   0 z  :   0 r0 :  10 r1 :   2 r2 :   5 r3 :  37 r4 :   5 
r5 :   5 r6 :   0 r7 :   0 r8 :   5 r9 :   5 r10:   5 r11:   6 r12:  11 
r13:   0 r14:   0 r15:   0 r16: 182 r17:  13 r18:  53 r19:  16 r20:  15 
r21:  15 r22:  22 r23:  40 r24:  11 r25:  15 r26:   8 r27:   6 r28:   0 
r29:   0 r30:  18 r31:   9 
Registers used: 26 out of 35 (74.3%)

"ATmega128" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   0 add   :   2 adiw  :  11 and   :   0 
andi  :   9 asr   :   2 bclr  :   0 bld   :   2 brbc  :   0 brbs  :   0 
brcc  :   3 brcs  :   0 break :   0 breq  :  22 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   1 brlo  :   1 brlt  :   0 brmi  :   1 
brne  :  37 brpl  :   1 brsh  :   1 brtc  :   5 brts  :   4 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   6 call  :   0 cbi   :   6 cbr   :   0 
clc   :   1 clh   :   0 cli   :   1 cln   :   0 clr   :  10 cls   :   0 
clt   :   2 clv   :   0 clz   :   3 com   :   8 cp    :   5 cpc   :   3 
cpi   :  15 cpse  :   0 dec   :  36 elpm  :   0 eor   :   2 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   1 ijmp  :   2 in    :  14 inc   :   6 
jmp   :   1 ld    :   6 ldd   :   0 ldi   :  93 lds   :   4 lpm   :  21 
lsl   :   2 lsr   :   4 mov   :  45 movw  :   0 mul   :   0 muls  :   0 
mulsu :   0 neg   :   0 nop   :   6 or    :   0 ori   :   3 out   :  13 
pop   :  38 push  :  35 rcall :  68 ret   :  36 reti  :   1 rjmp  :  55 
rol   :  11 ror   :  18 sbc   :   3 sbci  :   0 sbi   :  11 sbic  :   4 
sbis  :   0 sbiw  :   0 sbr   :   1 sbrc  :  17 sbrs  :   4 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   2 
sev   :   0 sez   :   1 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :   4 sub   :   3 subi  :   7 swap  :   4 tst   :  10 wdr   :   0 

Instructions used: 65 out of 114 (57.0%)

"ATmega128" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x00066c   1500     84   1584  131072   1.2%
[.dseg] 0x000100 0x000101      0      1      1    4096   0.0%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 1 warnings
